{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://angular-oauth2-oidc/types.ts","ng://angular-oauth2-oidc/base64-helper.ts","ng://angular-oauth2-oidc/token-validation/validation-handler.ts","ng://angular-oauth2-oidc/url-helper.service.ts","ng://angular-oauth2-oidc/events.ts","ng://angular-oauth2-oidc/auth.config.ts","ng://angular-oauth2-oidc/encoder.ts","ng://angular-oauth2-oidc/token-validation/hash-handler.ts","ng://angular-oauth2-oidc/oauth-service.ts","ng://angular-oauth2-oidc/oauth-module.config.ts","ng://angular-oauth2-oidc/interceptors/resource-server-error-handler.ts","ng://angular-oauth2-oidc/interceptors/default-oauth.interceptor.ts","ng://angular-oauth2-oidc/token-validation/null-validation-handler.ts","ng://angular-oauth2-oidc/factories.ts","ng://angular-oauth2-oidc/angular-oauth-oidc.module.ts","ng://angular-oauth2-oidc/token-validation/jwks-validation-handler.ts","ng://angular-oauth2-oidc/tokens.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__metadata","metadataKey","metadataValue","metadata","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","n","v","op","TypeError","call","pop","push","__values","o","s","m","__read","ar","error","preventClearHashAfterLogin","MemoryStorage","data","Map","getItem","get","removeItem","delete","setItem","set","Injectable","b64DecodeUnicode","str","base64","replace","decodeURIComponent","atob","split","map","charCodeAt","toString","slice","join","base64UrlEncode","btoa","ValidationHandler","AbstractValidationHandler","validateAtHash","params","hashAlg","inferHashAlgorithm","idTokenHeader","calcHash","accessToken","tokenHash","_a","leftMostHalf","substr","atHash","claimsAtHash","idTokenClaims","console","jwtHeader","alg","match","Error","UrlHelperService","getHashFragmentParams","customHashFragment","hash","window","location","indexOf","questionMarkPosition","parseQueryString","queryString","pairs","pair","separatorIndex","escapedKey","escapedValue","type","OAuthSuccessEvent","info","_this","_super","OAuthEvent","OAuthInfoEvent","OAuthErrorEvent","reason","json","clientId","redirectUri","postLogoutRedirectUri","loginUrl","scope","resource","rngUrl","oidc","requestAccessToken","options","issuer","logoutUrl","clearHashAfterLogin","tokenEndpoint","customTokenParameters","userinfoEndpoint","responseType","showDebugInformation","silentRefreshRedirectUri","silentRefreshMessagePrefix","silentRefreshShowIFrame","siletRefreshTimeout","silentRefreshTimeout","dummyClientSecret","requireHttps","strictDiscoveryDocumentValidation","jwks","customQueryParams","silentRefreshIFrameName","timeoutFactor","sessionChecksEnabled","sessionCheckIntervall","sessionCheckIFrameUrl","sessionCheckIFrameName","disableAtHashCheck","skipSubjectCheck","useIdTokenHintForSilentRefresh","skipIssuerCheck","nonceStateSeparator","useHttpBasicAuth","waitForTokenInMsec","disablePKCE","openUri","uri","href","assign","WebHttpUrlEncodingCodec","encodeKey","k","encodeURIComponent","encodeValue","decodeKey","decodeValue","HashHandler","DefaultHashHandler","valueToHash","algorithm","hashArray","sha256","array","toHashString2","byteArray","byteArray_1","byteArray_1_1","String","fromCharCode","toHashString","buffer","Uint8Array","byteArray_2","byteArray_2_1","OAuthService","ngZone","http","storage","tokenValidationHandler","config","urlHelper","logger","crypto","document","discoveryDocumentLoaded","state","eventsSubject","Subject","discoveryDocumentLoadedSubject","grantTypesSupported","inImplicitFlow","saveNoncesInLocalStorage","debug","discoveryDocumentLoaded$","asObservable","events","configure","setStorage","sessionStorage","ua","_b","navigator","userAgent","_c","includes","_d","setupRefreshTimer","AuthConfig","setupSessionCheck","configChanged","restartSessionChecksIfStillLoggedIn","hasValidIdToken","initSessionCheck","restartRefreshTimerIfStillLoggedIn","setupExpirationTimers","pipe","filter","subscribe","setupAutomaticSilentRefresh","listenTo","noPrompt","shouldRunSilentRefresh","tap","debounceTime","refreshInternal","catch","useSilentRefresh","silentRefresh","refreshToken","loadDiscoveryDocumentAndTryLogin","loadDiscoveryDocument","doc","tryLogin","loadDiscoveryDocumentAndLogin","hasValidAccessToken","initCodeFlow","initImplicitFlow","args","_i","validateUrlFromDiscoveryDocument","url","errors","httpsCheck","validateUrlForHttps","issuerCheck","validateUrlAgainstIssuer","lcUrl","toLowerCase","startsWith","assertUrlNotNullAndCorrectProtocol","description","clearAccessTokenTimer","clearIdTokenTimer","tokenReceivedSubscription","unsubscribe","setupAccessTokenTimer","setupIdTokenTimer","expiration","getAccessTokenExpiration","storedAt","getAccessTokenStoredAt","timeout","calcTimeout","runOutsideAngular","accessTokenTimeoutSubscription","of","delay","run","getIdTokenExpiration","getIdTokenStoredAt","idTokenTimeoutSubscription","stopAutomaticRefresh","now","Date","delta","Math","max","_storage","fullUrl","endsWith","validateDiscoveryDocument","authorization_endpoint","end_session_endpoint","grant_types_supported","token_endpoint","userinfo_endpoint","jwksUri","jwks_uri","check_session_iframe","loadJwks","event","discoveryDocument","err","warn","fetchTokenUsingPasswordFlowAndLoadUserProfile","userName","password","headers","HttpHeaders","fetchTokenUsingPasswordFlow","loadUserProfile","fetchTokenUsingExternalTokenAndLoadUserProfile","provider","external_token","fetchTokenUsingUsingExternalToken","getAccessToken","existingClaims","getIdentityClaims","sub","JSON","stringify","HttpParams","encoder","header","getOwnPropertyNames","post","tokenResponse","storeAccessTokenResponse","access_token","refresh_token","expires_in","extractRecognizedCustomParameters","switchMap","id_token","from","processIdToken","storeIdToken","removeSilentRefreshEventListener","silentRefreshPostMessageEventListener","removeEventListener","setupSilentRefreshEventListener","message","processMessageEventMessage","customRedirectUri","addEventListener","claims","getIdToken","existingIframe","getElementById","removeChild","silentRefreshSubject","iframe","createElement","id","createLoginUrl","setAttribute","style","appendChild","first","success","race","toPromise","initImplicitFlowInPopup","initLoginFlowInPopup","display","checkForPopupClosedTimer","windowRef","open","calculatePopupFeatures","setInterval","closed","cleanup","clearInterval","listener","close","log","height","width","left","screenLeft","outerWidth","screenTop","outerHeight","expectedPrefix","prefixedMessage","canPerformSessionCheck","getSessionState","setupSessionCheckEventListener","removeSessionCheckEventListener","sessionCheckEventListener","origin","handleSessionUnchanged","handleSessionChange","handleSessionError","stopSessionCheckTimer","waitForSilentRefreshAfterSessionChange","logOut","startSessionCheckTimer","sessionCheckTimer","checkSession","bind","sessionState","contentWindow","postMessage","loginHint","that","createAndSaveNonce","nonce","_h","seperationChar","createChallangeVerifierPairForPKCE","challenge","verifier","localStorage","keys","_e","initImplicitFlowInternal","additionalState","addParams","resetImplicitFlow","callOnTokenReceivedIfExists","onTokenReceived","tokenParams","idClaims","idToken","expiresIn","grantedScopes","customParameters","isArray","expiresInMilliSeconds","expiresAt","getTime","forEach","tryLoginCodeFlow","tryLoginImplicitFlow","charAt","querySource","substring","search","parts","getCodePartsFromUrl","code","history","replaceState","name","parseState","nonceInState","userState","handleLoginError","validateNonce","event_1","storeSessionState","getTokenFromCode","pkciVerifier","fetchAndProcessToken","disableOAuth2StateCheck","event_2","fallbackAccessTokenExpirationTimeInSec","validationHandler","idx","savedNonce","idTokenClaimsJson","idTokenExpiresAt","onLoginError","skipNonceCheck","tokenParts","headerJson","padBase64","parse","claimsJson","aud","every","iat","iss","issuedAtMSec","expiresAtMSec","exp","clockSkewInMSec","clockSkewInSec","validationParams","loadKeys","checkSignature","idTokenHeaderJson","checkAtHash","atHashValid","atHashCheckEnabled","getGrantedScopes","scopes","base64data","getRefreshToken","parseInt","getCustomTokenResponseProperty","requestedProperty","authorizationHeader","noRedirectToLogoutUrl","customParam","postLogoutUrl","createNonce","ngOnDestroy","silentRefreshFrame","remove","sessionCheckFrame","unreserved","size","self","bytes","getRandomValues","x","random","validateSignature","initLoginFlow","initCodeFlowInternal","challengeRaw","foundParameters","recognizedParameter","NgZone","HttpClient","OAuthStorage","Optional","OAuthLogger","Document","Inject","DOCUMENT","OAuthNoopResourceServerErrorHandler","handleError","throwError","DefaultOAuthInterceptor","authStorage","oAuthService","errorHandler","moduleConfig","checkUrl","resourceServer","customUrlValidation","allowedUrls","find","u","intercept","req","sendAccessToken","merge","token","catchError","take","mergeMap","clone","handle","OAuthResourceServerErrorHandler","OAuthModuleConfig","NullValidationHandler","createDefaultLogger","createDefaultStorage","OAuthModule","forRoot","validationHandlerClass","ngModule","OAuthModule_1","providers","provide","useFactory","useClass","useValue","HTTP_INTERCEPTORS","multi","NgModule","imports","CommonModule","declarations","exports","JwksValidationHandler","AUTH_CONFIG","InjectionToken"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Injectable } from '@angular/core';\n\n/**\n * Additional options that can be passed to tryLogin.\n */\nexport class LoginOptions {\n  /**\n   * Is called, after a token has been received and\n   * successfully validated.\n   *\n   * Deprecated:  Use property ``events`` on OAuthService instead.\n   */\n  onTokenReceived?: (receivedTokens: ReceivedTokens) => void;\n\n  /**\n   * Hook, to validate the received tokens.\n   *\n   * Deprecated:  Use property ``tokenValidationHandler`` on OAuthService instead.\n   */\n  validationHandler?: (receivedTokens: ReceivedTokens) => Promise<any>;\n\n  /**\n   * Called when tryLogin detects that the auth server\n   * included an error message into the hash fragment.\n   *\n   * Deprecated:  Use property ``events`` on OAuthService instead.\n   */\n  onLoginError?: (params: object) => void;\n\n  /**\n   * A custom hash fragment to be used instead of the\n   * actual one. This is used for silent refreshes, to\n   * pass the iframes hash fragment to this method, and\n   * is also used by popup flows in the same manner.\n   * This can be used with code flow, where is must be set\n   * to a hash symbol followed by the querystring. The\n   * question mark is optional, but may be present following\n   * the hash symbol.\n   */\n  customHashFragment?: string;\n\n  /**\n   * Set this to true to disable the oauth2 state\n   * check which is a best practice to avoid\n   * security attacks.\n   * As OIDC defines a nonce check that includes\n   * this, this can be set to true when only doing\n   * OIDC.\n   */\n  disableOAuth2StateCheck?: boolean;\n\n  /**\n   * Normally, you want to clear your hash fragment after\n   * the lib read the token(s) so that they are not displayed\n   * anymore in the url. If not, set this to true. For code flow\n   * this controls removing query string values.\n   */\n  preventClearHashAfterLogin? = false;\n\n  /**\n   * Set this for code flow if you used a custom redirect Uri\n   * when retrieving the code. This is used internally for silent\n   * refresh and popup flows.\n   */\n  customRedirectUri?: string;\n}\n\n/**\n * Defines the logging interface the OAuthService uses\n * internally. Is compatible with the `console` object,\n * but you can provide your own implementation as well\n * through dependency injection.\n */\nexport abstract class OAuthLogger {\n  abstract debug(message?: any, ...optionalParams: any[]): void;\n  abstract info(message?: any, ...optionalParams: any[]): void;\n  abstract log(message?: any, ...optionalParams: any[]): void;\n  abstract warn(message?: any, ...optionalParams: any[]): void;\n  abstract error(message?: any, ...optionalParams: any[]): void;\n}\n\n/**\n * Defines a simple storage that can be used for\n * storing the tokens at client side.\n * Is compatible to localStorage and sessionStorage,\n * but you can also create your own implementations.\n */\nexport abstract class OAuthStorage {\n  abstract getItem(key: string): string | null;\n  abstract removeItem(key: string): void;\n  abstract setItem(key: string, data: string): void;\n}\n\n@Injectable()\nexport class MemoryStorage implements OAuthStorage {\n  private data = new Map<string, string>();\n\n  getItem(key: string): string {\n    return this.data.get(key);\n  }\n\n  removeItem(key: string): void {\n    this.data.delete(key);\n  }\n\n  setItem(key: string, data: string): void {\n    this.data.set(key, data);\n  }\n}\n\n/**\n * Represents the received tokens, the received state\n * and the parsed claims from the id-token.\n */\nexport class ReceivedTokens {\n  idToken: string;\n  accessToken: string;\n  idClaims?: object;\n  state?: string;\n}\n\n/**\n * Represents the parsed and validated id_token.\n */\nexport interface ParsedIdToken {\n  idToken: string;\n  idTokenClaims: object;\n  idTokenHeader: object;\n  idTokenClaimsJson: string;\n  idTokenHeaderJson: string;\n  idTokenExpiresAt: number;\n}\n\n/**\n * Represents the response from the token endpoint\n * http://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint\n */\nexport interface TokenResponse {\n  access_token: string;\n  id_token: string;\n  token_type: string;\n  expires_in: number;\n  refresh_token: string;\n  scope: string;\n  state?: string;\n}\n\n/**\n * Represents the response from the user info endpoint\n * http://openid.net/specs/openid-connect-core-1_0.html#UserInfo\n */\nexport interface UserInfo {\n  sub: string;\n  [key: string]: any;\n}\n\n/**\n * Represents an OpenID Connect discovery document\n */\nexport interface OidcDiscoveryDoc {\n  issuer: string;\n  authorization_endpoint: string;\n  token_endpoint: string;\n  token_endpoint_auth_methods_supported: string[];\n  token_endpoint_auth_signing_alg_values_supported: string[];\n  userinfo_endpoint: string;\n  check_session_iframe: string;\n  end_session_endpoint: string;\n  jwks_uri: string;\n  registration_endpoint: string;\n  scopes_supported: string[];\n  response_types_supported: string[];\n  acr_values_supported: string[];\n  response_modes_supported: string[];\n  grant_types_supported: string[];\n  subject_types_supported: string[];\n  userinfo_signing_alg_values_supported: string[];\n  userinfo_encryption_alg_values_supported: string[];\n  userinfo_encryption_enc_values_supported: string[];\n  id_token_signing_alg_values_supported: string[];\n  id_token_encryption_alg_values_supported: string[];\n  id_token_encryption_enc_values_supported: string[];\n  request_object_signing_alg_values_supported: string[];\n  display_values_supported: string[];\n  claim_types_supported: string[];\n  claims_supported: string[];\n  claims_parameter_supported: boolean;\n  service_documentation: string;\n  ui_locales_supported: string[];\n}\n","// see: https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_.22Unicode_Problem.22\nexport function b64DecodeUnicode(str) {\n  const base64 = str.replace(/\\-/g, '+').replace(/\\_/g, '/');\n\n  return decodeURIComponent(\n    atob(base64)\n      .split('')\n      .map(function(c) {\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n      })\n      .join('')\n  );\n}\n\nexport function base64UrlEncode(str): string {\n  const base64 = btoa(str);\n  return base64\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '');\n}\n","import { base64UrlEncode } from '../base64-helper';\n\nexport interface ValidationParams {\n  idToken: string;\n  accessToken: string;\n  idTokenHeader: object;\n  idTokenClaims: object;\n  jwks: object;\n  loadKeys: () => Promise<object>;\n}\n\n/**\n * Interface for Handlers that are hooked in to\n * validate tokens.\n */\nexport abstract class ValidationHandler {\n  /**\n   * Validates the signature of an id_token.\n   */\n  public abstract validateSignature(\n    validationParams: ValidationParams\n  ): Promise<any>;\n\n  /**\n   * Validates the at_hash in an id_token against the received access_token.\n   */\n  public abstract validateAtHash(\n    validationParams: ValidationParams\n  ): Promise<boolean>;\n}\n\n/**\n * This abstract implementation of ValidationHandler already implements\n * the method validateAtHash. However, to make use of it,\n * you have to override the method calcHash.\n */\nexport abstract class AbstractValidationHandler implements ValidationHandler {\n  /**\n   * Validates the signature of an id_token.\n   */\n  abstract validateSignature(validationParams: ValidationParams): Promise<any>;\n\n  /**\n   * Validates the at_hash in an id_token against the received access_token.\n   */\n  async validateAtHash(params: ValidationParams): Promise<boolean> {\n    let hashAlg = this.inferHashAlgorithm(params.idTokenHeader);\n\n    let tokenHash = await this.calcHash(params.accessToken, hashAlg); // sha256(accessToken, { asString: true });\n\n    let leftMostHalf = tokenHash.substr(0, tokenHash.length / 2);\n\n    let atHash = base64UrlEncode(leftMostHalf);\n\n    let claimsAtHash = params.idTokenClaims['at_hash'].replace(/=/g, '');\n\n    if (atHash !== claimsAtHash) {\n      console.error('exptected at_hash: ' + atHash);\n      console.error('actual at_hash: ' + claimsAtHash);\n    }\n\n    return atHash === claimsAtHash;\n  }\n\n  /**\n   * Infers the name of the hash algorithm to use\n   * from the alg field of an id_token.\n   *\n   * @param jwtHeader the id_token's parsed header\n   */\n  protected inferHashAlgorithm(jwtHeader: object): string {\n    let alg: string = jwtHeader['alg'];\n\n    if (!alg.match(/^.S[0-9]{3}$/)) {\n      throw new Error('Algorithm not supported: ' + alg);\n    }\n\n    return 'sha-' + alg.substr(2);\n  }\n\n  /**\n   * Calculates the hash for the passed value by using\n   * the passed hash algorithm.\n   *\n   * @param valueToHash\n   * @param algorithm\n   */\n  protected abstract calcHash(\n    valueToHash: string,\n    algorithm: string\n  ): Promise<string>;\n}\n","import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class UrlHelperService {\n  public getHashFragmentParams(customHashFragment?: string): object {\n    let hash = customHashFragment || window.location.hash;\n\n    hash = decodeURIComponent(hash);\n\n    if (hash.indexOf('#') !== 0) {\n      return {};\n    }\n\n    const questionMarkPosition = hash.indexOf('?');\n\n    if (questionMarkPosition > -1) {\n      hash = hash.substr(questionMarkPosition + 1);\n    } else {\n      hash = hash.substr(1);\n    }\n\n    return this.parseQueryString(hash);\n  }\n\n  public parseQueryString(queryString: string): object {\n    const data = {};\n    let pairs, pair, separatorIndex, escapedKey, escapedValue, key, value;\n\n    if (queryString === null) {\n      return data;\n    }\n\n    pairs = queryString.split('&');\n\n    for (let i = 0; i < pairs.length; i++) {\n      pair = pairs[i];\n      separatorIndex = pair.indexOf('=');\n\n      if (separatorIndex === -1) {\n        escapedKey = pair;\n        escapedValue = null;\n      } else {\n        escapedKey = pair.substr(0, separatorIndex);\n        escapedValue = pair.substr(separatorIndex + 1);\n      }\n\n      key = decodeURIComponent(escapedKey);\n      value = decodeURIComponent(escapedValue);\n\n      if (key.substr(0, 1) === '/') {\n        key = key.substr(1);\n      }\n\n      data[key] = value;\n    }\n\n    return data;\n  }\n}\n","export type EventType =\n  | 'discovery_document_loaded'\n  | 'jwks_load_error'\n  | 'invalid_nonce_in_state'\n  | 'discovery_document_load_error'\n  | 'discovery_document_validation_error'\n  | 'user_profile_loaded'\n  | 'user_profile_load_error'\n  | 'token_received'\n  | 'token_error'\n  | 'code_error'\n  | 'token_refreshed'\n  | 'token_refresh_error'\n  | 'silent_refresh_error'\n  | 'silently_refreshed'\n  | 'silent_refresh_timeout'\n  | 'token_validation_error'\n  | 'token_expires'\n  | 'session_changed'\n  | 'session_error'\n  | 'session_terminated'\n  | 'logout'\n  | 'popup_closed'\n  | 'popup_blocked';\n\nexport abstract class OAuthEvent {\n  constructor(readonly type: EventType) {}\n}\n\nexport class OAuthSuccessEvent extends OAuthEvent {\n  constructor(type: EventType, readonly info: any = null) {\n    super(type);\n  }\n}\n\nexport class OAuthInfoEvent extends OAuthEvent {\n  constructor(type: EventType, readonly info: any = null) {\n    super(type);\n  }\n}\n\nexport class OAuthErrorEvent extends OAuthEvent {\n  constructor(\n    type: EventType,\n    readonly reason: object,\n    readonly params: object = null\n  ) {\n    super(type);\n  }\n}\n","export class AuthConfig {\n  /**\n   * The client's id as registered with the auth server\n   */\n  public clientId? = '';\n\n  /**\n   * The client's redirectUri as registered with the auth server\n   */\n  public redirectUri? = '';\n\n  /**\n   * An optional second redirectUri where the auth server\n   * redirects the user to after logging out.\n   */\n  public postLogoutRedirectUri? = '';\n\n  /**\n   * The auth server's endpoint that allows to log\n   * the user in when using implicit flow.\n   */\n  public loginUrl? = '';\n\n  /**\n   * The requested scopes\n   */\n  public scope? = 'openid profile';\n\n  public resource? = '';\n\n  public rngUrl? = '';\n\n  /**\n   * Defines whether to use OpenId Connect during\n   * implicit flow.\n   */\n  public oidc? = true;\n\n  /**\n   * Defines whether to request an access token during\n   * implicit flow.\n   */\n  public requestAccessToken? = true;\n\n  public options?: any = null;\n\n  /**\n   * The issuer's uri.\n   */\n  public issuer? = '';\n\n  /**\n   * The logout url.\n   */\n  public logoutUrl? = '';\n\n  /**\n   * Defines whether to clear the hash fragment after logging in.\n   */\n  public clearHashAfterLogin? = true;\n\n  /**\n   * Url of the token endpoint as defined by OpenId Connect and OAuth 2.\n   */\n  public tokenEndpoint?: string = null;\n\n  /**\n   * Names of known parameters sent out in the TokenResponse. https://tools.ietf.org/html/rfc6749#section-5.1\n   */\n  public customTokenParameters?: string[] = [];\n\n  /**\n   * Url of the userinfo endpoint as defined by OpenId Connect.\n   */\n  public userinfoEndpoint?: string = null;\n\n  public responseType? = '';\n\n  /**\n   * Defines whether additional debug information should\n   * be shown at the console. Note that in certain browsers\n   * the verbosity of the console needs to be explicitly set\n   * to include Debug level messages.\n   */\n  public showDebugInformation? = false;\n\n  /**\n   * The redirect uri used when doing silent refresh.\n   */\n  public silentRefreshRedirectUri? = '';\n\n  public silentRefreshMessagePrefix? = '';\n\n  /**\n   * Set this to true to display the iframe used for\n   * silent refresh for debugging.\n   */\n  public silentRefreshShowIFrame? = false;\n\n  /**\n   * Timeout for silent refresh.\n   * @internal\n   * depreacted b/c of typo, see silentRefreshTimeout\n   */\n  public siletRefreshTimeout?: number = 1000 * 20;\n\n  /**\n   * Timeout for silent refresh.\n   */\n  public silentRefreshTimeout?: number = 1000 * 20;\n\n  /**\n   * Some auth servers don't allow using password flow\n   * w/o a client secret while the standards do not\n   * demand for it. In this case, you can set a password\n   * here. As this password is exposed to the public\n   * it does not bring additional security and is therefore\n   * as good as using no password.\n   */\n  public dummyClientSecret?: string = null;\n\n  /**\n   * Defines whether https is required.\n   * The default value is remoteOnly which only allows\n   * http for localhost, while every other domains need\n   * to be used with https.\n   */\n  public requireHttps?: boolean | 'remoteOnly' = 'remoteOnly';\n\n  /**\n   * Defines whether every url provided by the discovery\n   * document has to start with the issuer's url.\n   */\n  public strictDiscoveryDocumentValidation? = true;\n\n  /**\n   * JSON Web Key Set (https://tools.ietf.org/html/rfc7517)\n   * with keys used to validate received id_tokens.\n   * This is taken out of the disovery document. Can be set manually too.\n   */\n  public jwks?: object = null;\n\n  /**\n   * Map with additional query parameter that are appended to\n   * the request when initializing implicit flow.\n   */\n  public customQueryParams?: object = null;\n\n  public silentRefreshIFrameName? = 'angular-oauth-oidc-silent-refresh-iframe';\n\n  /**\n   * Defines when the token_timeout event should be raised.\n   * If you set this to the default value 0.75, the event\n   * is triggered after 75% of the token's life time.\n   */\n  public timeoutFactor? = 0.75;\n\n  /**\n   * If true, the lib will try to check whether the user\n   * is still logged in on a regular basis as described\n   * in http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\n   */\n  public sessionChecksEnabled? = false;\n\n  /**\n   * Interval in msec for checking the session\n   * according to http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\n   */\n  public sessionCheckIntervall? = 3 * 1000;\n\n  /**\n   * Url for the iframe used for session checks\n   */\n  public sessionCheckIFrameUrl?: string = null;\n\n  /**\n   * Name of the iframe to use for session checks\n   */\n  public sessionCheckIFrameName? = 'angular-oauth-oidc-check-session-iframe';\n\n  /**\n   * This property has been introduced to disable at_hash checks\n   * and is indented for Identity Provider that does not deliver\n   * an at_hash EVEN THOUGH its recommended by the OIDC specs.\n   * Of course, when disabling these checks the we are bypassing\n   * a security check which means we are more vulnerable.\n   */\n  public disableAtHashCheck? = false;\n\n  /**\n   * Defines wether to check the subject of a refreshed token after silent refresh.\n   * Normally, it should be the same as before.\n   */\n  public skipSubjectCheck? = false;\n\n  public useIdTokenHintForSilentRefresh? = false;\n\n  /**\n   * Defined whether to skip the validation of the issuer in the discovery document.\n   * Normally, the discovey document's url starts with the url of the issuer.\n   */\n  public skipIssuerCheck? = false;\n\n  /**\n   * According to rfc6749 it is recommended (but not required) that the auth\n   * server exposes the access_token's life time in seconds.\n   * This is a fallback value for the case this value is not exposed.\n   */\n  public fallbackAccessTokenExpirationTimeInSec?: number;\n\n  /**\n   * final state sent to issuer is built as follows:\n   * state = nonce + nonceStateSeparator + additional state\n   * Default separator is ';' (encoded %3B).\n   * In rare cases, this character might be forbidden or inconvenient to use by the issuer so it can be customized.\n   */\n  public nonceStateSeparator? = ';';\n\n  /**\n   * Set this to true to use HTTP BASIC auth for AJAX calls\n   */\n  public useHttpBasicAuth? = false;\n\n  /**\n   * The window of time (in seconds) to allow the current time to deviate when validating id_token's iat and exp values.\n   */\n  public clockSkewInSec?: number;\n\n  /**\n   * The interceptors waits this time span if there is no token\n   */\n  public waitForTokenInMsec? = 0;\n\n  /**\n   * Set this to true if you want to use silent refresh together with\n   * code flow. As silent refresh is the only option for refreshing\n   * with implicit flow, you don't need to explicitly turn it on in\n   * this case.\n   */\n  public useSilentRefresh?;\n\n  /**\n   * Code Flow is by defauld used together with PKCI which is also higly recommented.\n   * You can disbale it here by setting this flag to true.\n   * https://tools.ietf.org/html/rfc7636#section-1.1\n   */\n  public disablePKCE? = false;\n\n  constructor(json?: Partial<AuthConfig>) {\n    if (json) {\n      Object.assign(this, json);\n    }\n  }\n\n  /**\n   * This property allows you to override the method that is used to open the login url,\n   * allowing a way for implementations to specify their own method of routing to new\n   * urls.\n   */\n  public openUri?: (uri: string) => void = uri => {\n    location.href = uri;\n  };\n}\n","import { HttpParameterCodec } from '@angular/common/http';\n/**\n * This custom encoder allows charactes like +, % and / to be used in passwords\n */\nexport class WebHttpUrlEncodingCodec implements HttpParameterCodec {\n  encodeKey(k: string): string {\n    return encodeURIComponent(k);\n  }\n\n  encodeValue(v: string): string {\n    return encodeURIComponent(v);\n  }\n\n  decodeKey(k: string): string {\n    return decodeURIComponent(k);\n  }\n\n  decodeValue(v: string) {\n    return decodeURIComponent(v);\n  }\n}\n","import { Injectable } from '@angular/core';\n\nimport { sha256 } from 'js-sha256';\n\n/**\n * Abstraction for crypto algorithms\n */\nexport abstract class HashHandler {\n  abstract calcHash(valueToHash: string, algorithm: string): Promise<string>;\n}\n\n@Injectable()\nexport class DefaultHashHandler implements HashHandler {\n  async calcHash(valueToHash: string, algorithm: string): Promise<string> {\n    // const encoder = new TextEncoder();\n    // const hashArray = await window.crypto.subtle.digest(algorithm, data);\n    // const data = encoder.encode(valueToHash);\n\n    const hashArray = sha256.array(valueToHash);\n    // const hashString = this.toHashString(hashArray);\n    const hashString = this.toHashString2(hashArray);\n\n    return hashString;\n  }\n\n  toHashString2(byteArray: number[]) {\n    let result = '';\n    for (let e of byteArray) {\n      result += String.fromCharCode(e);\n    }\n    return result;\n  }\n\n  toHashString(buffer: ArrayBuffer) {\n    const byteArray = new Uint8Array(buffer);\n    let result = '';\n    for (let e of byteArray) {\n      result += String.fromCharCode(e);\n    }\n    return result;\n  }\n\n  // hexString(buffer) {\n  //     const byteArray = new Uint8Array(buffer);\n  //     const hexCodes = [...byteArray].map(value => {\n  //       const hexCode = value.toString(16);\n  //       const paddedHexCode = hexCode.padStart(2, '0');\n  //       return paddedHexCode;\n  //     });\n\n  //     return hexCodes.join('');\n  //   }\n\n  // toHashString(hexString: string) {\n  //   let result = '';\n  //   for (let i = 0; i < hexString.length; i += 2) {\n  //     let hexDigit = hexString.charAt(i) + hexString.charAt(i + 1);\n  //     let num = parseInt(hexDigit, 16);\n  //     result += String.fromCharCode(num);\n  //   }\n  //   return result;\n  // }\n}\n","import { Injectable, NgZone, Optional, OnDestroy, Inject } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';\nimport { Observable, Subject, Subscription, of, race, from } from 'rxjs';\nimport {\n  filter,\n  delay,\n  first,\n  tap,\n  map,\n  switchMap,\n  debounceTime\n} from 'rxjs/operators';\nimport { DOCUMENT } from '@angular/common';\n\nimport {\n  ValidationHandler,\n  ValidationParams\n} from './token-validation/validation-handler';\nimport { UrlHelperService } from './url-helper.service';\nimport {\n  OAuthEvent,\n  OAuthInfoEvent,\n  OAuthErrorEvent,\n  OAuthSuccessEvent\n} from './events';\nimport {\n  OAuthLogger,\n  OAuthStorage,\n  LoginOptions,\n  ParsedIdToken,\n  OidcDiscoveryDoc,\n  TokenResponse,\n  UserInfo\n} from './types';\nimport { b64DecodeUnicode, base64UrlEncode } from './base64-helper';\nimport { AuthConfig } from './auth.config';\nimport { WebHttpUrlEncodingCodec } from './encoder';\nimport { HashHandler } from './token-validation/hash-handler';\n\n/**\n * Service for logging in and logging out with\n * OIDC and OAuth2. Supports implicit flow and\n * password flow.\n */\n@Injectable()\nexport class OAuthService extends AuthConfig implements OnDestroy {\n  // Extending AuthConfig ist just for LEGACY reasons\n  // to not break existing code.\n\n  /**\n   * The ValidationHandler used to validate received\n   * id_tokens.\n   */\n  public tokenValidationHandler: ValidationHandler;\n\n  /**\n   * @internal\n   * Deprecated:  use property events instead\n   */\n  public discoveryDocumentLoaded = false;\n\n  /**\n   * @internal\n   * Deprecated:  use property events instead\n   */\n  public discoveryDocumentLoaded$: Observable<OidcDiscoveryDoc>;\n\n  /**\n   * Informs about events, like token_received or token_expires.\n   * See the string enum EventType for a full list of event types.\n   */\n  public events: Observable<OAuthEvent>;\n\n  /**\n   * The received (passed around) state, when logging\n   * in with implicit flow.\n   */\n  public state? = '';\n\n  protected eventsSubject: Subject<OAuthEvent> = new Subject<OAuthEvent>();\n  protected discoveryDocumentLoadedSubject: Subject<\n    OidcDiscoveryDoc\n  > = new Subject<OidcDiscoveryDoc>();\n  protected silentRefreshPostMessageEventListener: EventListener;\n  protected grantTypesSupported: Array<string> = [];\n  protected _storage: OAuthStorage;\n  protected accessTokenTimeoutSubscription: Subscription;\n  protected idTokenTimeoutSubscription: Subscription;\n  protected tokenReceivedSubscription: Subscription;\n  protected sessionCheckEventListener: EventListener;\n  protected jwksUri: string;\n  protected sessionCheckTimer: any;\n  protected silentRefreshSubject: string;\n  protected inImplicitFlow = false;\n\n  protected saveNoncesInLocalStorage = false;\n\n  constructor(\n    protected ngZone: NgZone,\n    protected http: HttpClient,\n    @Optional() storage: OAuthStorage,\n    @Optional() tokenValidationHandler: ValidationHandler,\n    @Optional() protected config: AuthConfig,\n    protected urlHelper: UrlHelperService,\n    protected logger: OAuthLogger,\n    @Optional() protected crypto: HashHandler,\n    @Inject(DOCUMENT) private document: Document\n  ) {\n    super();\n\n    this.debug('angular-oauth2-oidc v8-beta');\n\n    this.discoveryDocumentLoaded$ = this.discoveryDocumentLoadedSubject.asObservable();\n    this.events = this.eventsSubject.asObservable();\n\n    if (tokenValidationHandler) {\n      this.tokenValidationHandler = tokenValidationHandler;\n    }\n\n    if (config) {\n      this.configure(config);\n    }\n\n    try {\n      if (storage) {\n        this.setStorage(storage);\n      } else if (typeof sessionStorage !== 'undefined') {\n        this.setStorage(sessionStorage);\n      }\n    } catch (e) {\n      console.error(\n        'No OAuthStorage provided and cannot access default (sessionStorage).' +\n          'Consider providing a custom OAuthStorage implementation in your module.',\n        e\n      );\n    }\n\n    // in IE, sessionStorage does not always survive a redirect\n    if (\n      typeof window !== 'undefined' &&\n      typeof window['localStorage'] !== 'undefined'\n    ) {\n      const ua = window?.navigator?.userAgent;\n      const msie = ua?.includes('MSIE ') || ua?.includes('Trident');\n\n      if (msie) {\n        this.saveNoncesInLocalStorage = true;\n      }\n    }\n\n    this.setupRefreshTimer();\n  }\n\n  /**\n   * Use this method to configure the service\n   * @param config the configuration\n   */\n  public configure(config: AuthConfig): void {\n    // For the sake of downward compatibility with\n    // original configuration API\n    Object.assign(this, new AuthConfig(), config);\n\n    this.config = Object.assign({} as AuthConfig, new AuthConfig(), config);\n\n    if (this.sessionChecksEnabled) {\n      this.setupSessionCheck();\n    }\n\n    this.configChanged();\n  }\n\n  protected configChanged(): void {\n    this.setupRefreshTimer();\n  }\n\n  public restartSessionChecksIfStillLoggedIn(): void {\n    if (this.hasValidIdToken()) {\n      this.initSessionCheck();\n    }\n  }\n\n  protected restartRefreshTimerIfStillLoggedIn(): void {\n    this.setupExpirationTimers();\n  }\n\n  protected setupSessionCheck(): void {\n    this.events.pipe(filter(e => e.type === 'token_received')).subscribe(e => {\n      this.initSessionCheck();\n    });\n  }\n\n  /**\n   * Will setup up silent refreshing for when the token is\n   * about to expire. When the user is logged out via this.logOut method, the\n   * silent refreshing will pause and not refresh the tokens until the user is\n   * logged back in via receiving a new token.\n   * @param params Additional parameter to pass\n   * @param listenTo Setup automatic refresh of a specific token type\n   */\n  public setupAutomaticSilentRefresh(\n    params: object = {},\n    listenTo?: 'access_token' | 'id_token' | 'any',\n    noPrompt = true\n  ): void {\n    let shouldRunSilentRefresh = true;\n    this.events\n      .pipe(\n        tap(e => {\n          if (e.type === 'token_received') {\n            shouldRunSilentRefresh = true;\n          } else if (e.type === 'logout') {\n            shouldRunSilentRefresh = false;\n          }\n        }),\n        filter(e => e.type === 'token_expires'),\n        debounceTime(1000)\n      )\n      .subscribe(e => {\n        const event = e as OAuthInfoEvent;\n        if (\n          (listenTo == null || listenTo === 'any' || event.info === listenTo) &&\n          shouldRunSilentRefresh\n        ) {\n          // this.silentRefresh(params, noPrompt).catch(_ => {\n          this.refreshInternal(params, noPrompt).catch(_ => {\n            this.debug('Automatic silent refresh did not work');\n          });\n        }\n      });\n\n    this.restartRefreshTimerIfStillLoggedIn();\n  }\n\n  protected refreshInternal(\n    params,\n    noPrompt\n  ): Promise<TokenResponse | OAuthEvent> {\n    if (!this.useSilentRefresh && this.responseType === 'code') {\n      return this.refreshToken();\n    } else {\n      return this.silentRefresh(params, noPrompt);\n    }\n  }\n\n  /**\n   * Convenience method that first calls `loadDiscoveryDocument(...)` and\n   * directly chains using the `then(...)` part of the promise to call\n   * the `tryLogin(...)` method.\n   *\n   * @param options LoginOptions to pass through to `tryLogin(...)`\n   */\n  public loadDiscoveryDocumentAndTryLogin(\n    options: LoginOptions = null\n  ): Promise<boolean> {\n    return this.loadDiscoveryDocument().then(doc => {\n      return this.tryLogin(options);\n    });\n  }\n\n  /**\n   * Convenience method that first calls `loadDiscoveryDocumentAndTryLogin(...)`\n   * and if then chains to `initLoginFlow()`, but only if there is no valid\n   * IdToken or no valid AccessToken.\n   *\n   * @param options LoginOptions to pass through to `tryLogin(...)`\n   */\n  public loadDiscoveryDocumentAndLogin(\n    options: LoginOptions & { state?: string } = null\n  ): Promise<boolean> {\n    if (!options) {\n      options = { state: '' };\n    }\n    return this.loadDiscoveryDocumentAndTryLogin(options).then(_ => {\n      if (!this.hasValidIdToken() || !this.hasValidAccessToken()) {\n        if (this.responseType === 'code') {\n          this.initCodeFlow();\n        } else {\n          this.initImplicitFlow();\n        }\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n\n  protected debug(...args): void {\n    if (this.showDebugInformation) {\n      this.logger.debug.apply(this.logger, args);\n    }\n  }\n\n  protected validateUrlFromDiscoveryDocument(url: string): string[] {\n    const errors: string[] = [];\n    const httpsCheck = this.validateUrlForHttps(url);\n    const issuerCheck = this.validateUrlAgainstIssuer(url);\n\n    if (!httpsCheck) {\n      errors.push(\n        'https for all urls required. Also for urls received by discovery.'\n      );\n    }\n\n    if (!issuerCheck) {\n      errors.push(\n        'Every url in discovery document has to start with the issuer url.' +\n          'Also see property strictDiscoveryDocumentValidation.'\n      );\n    }\n\n    return errors;\n  }\n\n  protected validateUrlForHttps(url: string): boolean {\n    if (!url) {\n      return true;\n    }\n\n    const lcUrl = url.toLowerCase();\n\n    if (this.requireHttps === false) {\n      return true;\n    }\n\n    if (\n      (lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/) ||\n        lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/)) &&\n      this.requireHttps === 'remoteOnly'\n    ) {\n      return true;\n    }\n\n    return lcUrl.startsWith('https://');\n  }\n\n  protected assertUrlNotNullAndCorrectProtocol(\n    url: string | undefined,\n    description: string\n  ) {\n    if (!url) {\n      throw new Error(`'${description}' should not be null`);\n    }\n    if (!this.validateUrlForHttps(url)) {\n      throw new Error(\n        `'${description}' must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).`\n      );\n    }\n  }\n\n  protected validateUrlAgainstIssuer(url: string) {\n    if (!this.strictDiscoveryDocumentValidation) {\n      return true;\n    }\n    if (!url) {\n      return true;\n    }\n    return url.toLowerCase().startsWith(this.issuer.toLowerCase());\n  }\n\n  protected setupRefreshTimer(): void {\n    if (typeof window === 'undefined') {\n      this.debug('timer not supported on this plattform');\n      return;\n    }\n\n    if (this.hasValidIdToken() || this.hasValidAccessToken()) {\n      this.clearAccessTokenTimer();\n      this.clearIdTokenTimer();\n      this.setupExpirationTimers();\n    }\n\n    if (this.tokenReceivedSubscription)\n      this.tokenReceivedSubscription.unsubscribe();\n\n    this.tokenReceivedSubscription = this.events\n      .pipe(filter(e => e.type === 'token_received'))\n      .subscribe(_ => {\n        this.clearAccessTokenTimer();\n        this.clearIdTokenTimer();\n        this.setupExpirationTimers();\n      });\n  }\n\n  protected setupExpirationTimers(): void {\n    if (this.hasValidAccessToken()) {\n      this.setupAccessTokenTimer();\n    }\n\n    if (this.hasValidIdToken()) {\n      this.setupIdTokenTimer();\n    }\n  }\n\n  protected setupAccessTokenTimer(): void {\n    const expiration = this.getAccessTokenExpiration();\n    const storedAt = this.getAccessTokenStoredAt();\n    const timeout = this.calcTimeout(storedAt, expiration);\n\n    this.ngZone.runOutsideAngular(() => {\n      this.accessTokenTimeoutSubscription = of(\n        new OAuthInfoEvent('token_expires', 'access_token')\n      )\n        .pipe(delay(timeout))\n        .subscribe(e => {\n          this.ngZone.run(() => {\n            this.eventsSubject.next(e);\n          });\n        });\n    });\n  }\n\n  protected setupIdTokenTimer(): void {\n    const expiration = this.getIdTokenExpiration();\n    const storedAt = this.getIdTokenStoredAt();\n    const timeout = this.calcTimeout(storedAt, expiration);\n\n    this.ngZone.runOutsideAngular(() => {\n      this.idTokenTimeoutSubscription = of(\n        new OAuthInfoEvent('token_expires', 'id_token')\n      )\n        .pipe(delay(timeout))\n        .subscribe(e => {\n          this.ngZone.run(() => {\n            this.eventsSubject.next(e);\n          });\n        });\n    });\n  }\n\n  /**\n   * Stops timers for automatic refresh.\n   * To restart it, call setupAutomaticSilentRefresh again.\n   */\n  public stopAutomaticRefresh() {\n    this.clearAccessTokenTimer();\n    this.clearIdTokenTimer();\n  }\n\n  protected clearAccessTokenTimer(): void {\n    if (this.accessTokenTimeoutSubscription) {\n      this.accessTokenTimeoutSubscription.unsubscribe();\n    }\n  }\n\n  protected clearIdTokenTimer(): void {\n    if (this.idTokenTimeoutSubscription) {\n      this.idTokenTimeoutSubscription.unsubscribe();\n    }\n  }\n\n  protected calcTimeout(storedAt: number, expiration: number): number {\n    const now = Date.now();\n    const delta =\n      (expiration - storedAt) * this.timeoutFactor - (now - storedAt);\n    return Math.max(0, delta);\n  }\n\n  /**\n   * DEPRECATED. Use a provider for OAuthStorage instead:\n   *\n   * { provide: OAuthStorage, useFactory: oAuthStorageFactory }\n   * export function oAuthStorageFactory(): OAuthStorage { return localStorage; }\n   * Sets a custom storage used to store the received\n   * tokens on client side. By default, the browser's\n   * sessionStorage is used.\n   * @ignore\n   *\n   * @param storage\n   */\n  public setStorage(storage: OAuthStorage): void {\n    this._storage = storage;\n    this.configChanged();\n  }\n\n  /**\n   * Loads the discovery document to configure most\n   * properties of this service. The url of the discovery\n   * document is infered from the issuer's url according\n   * to the OpenId Connect spec. To use another url you\n   * can pass it to to optional parameter fullUrl.\n   *\n   * @param fullUrl\n   */\n  public loadDiscoveryDocument(\n    fullUrl: string = null\n  ): Promise<OAuthSuccessEvent> {\n    return new Promise((resolve, reject) => {\n      if (!fullUrl) {\n        fullUrl = this.issuer || '';\n        if (!fullUrl.endsWith('/')) {\n          fullUrl += '/';\n        }\n        fullUrl += '.well-known/openid-configuration';\n      }\n\n      if (!this.validateUrlForHttps(fullUrl)) {\n        reject(\n          \"issuer  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\"\n        );\n        return;\n      }\n\n      this.http.get<OidcDiscoveryDoc>(fullUrl).subscribe(\n        doc => {\n          if (!this.validateDiscoveryDocument(doc)) {\n            this.eventsSubject.next(\n              new OAuthErrorEvent('discovery_document_validation_error', null)\n            );\n            reject('discovery_document_validation_error');\n            return;\n          }\n\n          this.loginUrl = doc.authorization_endpoint;\n          this.logoutUrl = doc.end_session_endpoint || this.logoutUrl;\n          this.grantTypesSupported = doc.grant_types_supported;\n          this.issuer = doc.issuer;\n          this.tokenEndpoint = doc.token_endpoint;\n          this.userinfoEndpoint =\n            doc.userinfo_endpoint || this.userinfoEndpoint;\n          this.jwksUri = doc.jwks_uri;\n          this.sessionCheckIFrameUrl =\n            doc.check_session_iframe || this.sessionCheckIFrameUrl;\n\n          this.discoveryDocumentLoaded = true;\n          this.discoveryDocumentLoadedSubject.next(doc);\n\n          if (this.sessionChecksEnabled) {\n            this.restartSessionChecksIfStillLoggedIn();\n          }\n\n          this.loadJwks()\n            .then(jwks => {\n              const result: object = {\n                discoveryDocument: doc,\n                jwks: jwks\n              };\n\n              const event = new OAuthSuccessEvent(\n                'discovery_document_loaded',\n                result\n              );\n              this.eventsSubject.next(event);\n              resolve(event);\n              return;\n            })\n            .catch(err => {\n              this.eventsSubject.next(\n                new OAuthErrorEvent('discovery_document_load_error', err)\n              );\n              reject(err);\n              return;\n            });\n        },\n        err => {\n          this.logger.error('error loading discovery document', err);\n          this.eventsSubject.next(\n            new OAuthErrorEvent('discovery_document_load_error', err)\n          );\n          reject(err);\n        }\n      );\n    });\n  }\n\n  protected loadJwks(): Promise<object> {\n    return new Promise<object>((resolve, reject) => {\n      if (this.jwksUri) {\n        this.http.get(this.jwksUri).subscribe(\n          jwks => {\n            this.jwks = jwks;\n            this.eventsSubject.next(\n              new OAuthSuccessEvent('discovery_document_loaded')\n            );\n            resolve(jwks);\n          },\n          err => {\n            this.logger.error('error loading jwks', err);\n            this.eventsSubject.next(\n              new OAuthErrorEvent('jwks_load_error', err)\n            );\n            reject(err);\n          }\n        );\n      } else {\n        resolve(null);\n      }\n    });\n  }\n\n  protected validateDiscoveryDocument(doc: OidcDiscoveryDoc): boolean {\n    let errors: string[];\n\n    if (!this.skipIssuerCheck && doc.issuer !== this.issuer) {\n      this.logger.error(\n        'invalid issuer in discovery document',\n        'expected: ' + this.issuer,\n        'current: ' + doc.issuer\n      );\n      return false;\n    }\n\n    errors = this.validateUrlFromDiscoveryDocument(doc.authorization_endpoint);\n    if (errors.length > 0) {\n      this.logger.error(\n        'error validating authorization_endpoint in discovery document',\n        errors\n      );\n      return false;\n    }\n\n    errors = this.validateUrlFromDiscoveryDocument(doc.end_session_endpoint);\n    if (errors.length > 0) {\n      this.logger.error(\n        'error validating end_session_endpoint in discovery document',\n        errors\n      );\n      return false;\n    }\n\n    errors = this.validateUrlFromDiscoveryDocument(doc.token_endpoint);\n    if (errors.length > 0) {\n      this.logger.error(\n        'error validating token_endpoint in discovery document',\n        errors\n      );\n    }\n\n    errors = this.validateUrlFromDiscoveryDocument(doc.userinfo_endpoint);\n    if (errors.length > 0) {\n      this.logger.error(\n        'error validating userinfo_endpoint in discovery document',\n        errors\n      );\n      return false;\n    }\n\n    errors = this.validateUrlFromDiscoveryDocument(doc.jwks_uri);\n    if (errors.length > 0) {\n      this.logger.error(\n        'error validating jwks_uri in discovery document',\n        errors\n      );\n      return false;\n    }\n\n    if (this.sessionChecksEnabled && !doc.check_session_iframe) {\n      this.logger.warn(\n        'sessionChecksEnabled is activated but discovery document' +\n          ' does not contain a check_session_iframe field'\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * Uses password flow to exchange userName and password for an\n   * access_token. After receiving the access_token, this method\n   * uses it to query the userinfo endpoint in order to get information\n   * about the user in question.\n   *\n   * When using this, make sure that the property oidc is set to false.\n   * Otherwise stricter validations take place that make this operation\n   * fail.\n   *\n   * @param userName\n   * @param password\n   * @param headers Optional additional http-headers.\n   */\n  public fetchTokenUsingPasswordFlowAndLoadUserProfile(\n    userName: string,\n    password: string,\n    headers: HttpHeaders = new HttpHeaders()\n  ): Promise<UserInfo> {\n    return this.fetchTokenUsingPasswordFlow(\n      userName,\n      password,\n      headers\n    ).then(() => this.loadUserProfile());\n  }\n\n  /**\n   * Uses external token and provider for an\n   * access_token. After receiving the access_token, this method\n   * uses it to query the userinfo endpoint in order to get information\n   * about the user in question.\n   *\n   * When using this, make sure that the property oidc is set to false.\n   * Otherwise stricter validations take place that make this operation\n   * fail.\n   *\n   * @param provider\n   * @param external_token\n   * @param headers Optional additional http-headers.\n   */\n  public fetchTokenUsingExternalTokenAndLoadUserProfile(\n    provider: string,\n    external_token: string,\n    headers: HttpHeaders = new HttpHeaders()\n  ): Promise<object> {\n    return this.fetchTokenUsingUsingExternalToken(\n      provider,\n      external_token,\n      headers\n    ).then(() => this.loadUserProfile());\n  }\n\n  /**\n   * Loads the user profile by accessing the user info endpoint defined by OpenId Connect.\n   *\n   * When using this with OAuth2 password flow, make sure that the property oidc is set to false.\n   * Otherwise stricter validations take place that make this operation fail.\n   */\n  public loadUserProfile(): Promise<UserInfo> {\n    if (!this.hasValidAccessToken()) {\n      throw new Error('Can not load User Profile without access_token');\n    }\n    if (!this.validateUrlForHttps(this.userinfoEndpoint)) {\n      throw new Error(\n        \"userinfoEndpoint must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\"\n      );\n    }\n\n    return new Promise((resolve, reject) => {\n      const headers = new HttpHeaders().set(\n        'Authorization',\n        'Bearer ' + this.getAccessToken()\n      );\n\n      this.http\n        .get<UserInfo>(this.userinfoEndpoint, { headers })\n        .subscribe(\n          info => {\n            this.debug('userinfo received', info);\n\n            const existingClaims = this.getIdentityClaims() || {};\n\n            if (!this.skipSubjectCheck) {\n              if (\n                this.oidc &&\n                (!existingClaims['sub'] || info.sub !== existingClaims['sub'])\n              ) {\n                const err =\n                  'if property oidc is true, the received user-id (sub) has to be the user-id ' +\n                  'of the user that has logged in with oidc.\\n' +\n                  'if you are not using oidc but just oauth2 password flow set oidc to false';\n\n                reject(err);\n                return;\n              }\n            }\n\n            info = Object.assign({}, existingClaims, info);\n\n            this._storage.setItem('id_token_claims_obj', JSON.stringify(info));\n            this.eventsSubject.next(\n              new OAuthSuccessEvent('user_profile_loaded')\n            );\n            resolve(info);\n          },\n          err => {\n            this.logger.error('error loading user info', err);\n            this.eventsSubject.next(\n              new OAuthErrorEvent('user_profile_load_error', err)\n            );\n            reject(err);\n          }\n        );\n    });\n  }\n\n  /**\n   * Uses provider and external token for an access_token.\n   * @param provider\n   * @param external_token\n   * @param headers Optional additional http-headers.\n   */\n  public fetchTokenUsingUsingExternalToken(\n    provider: string,\n    external_token: string,\n    headers: HttpHeaders = new HttpHeaders()\n  ): Promise<object> {\n    if (!this.validateUrlForHttps(this.tokenEndpoint)) {\n      throw new Error(\n        'tokenEndpoint must use https, or config value for property requireHttps must allow http'\n      );\n    }\n\n    return new Promise((resolve, reject) => {\n      /**\n       * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to\n       * serialize and parse URL parameter keys and values.\n       *\n       * @stable\n       */\n      let params = new HttpParams({ encoder: new WebHttpUrlEncodingCodec() })\n        .set('grant_type', 'external')\n        .set('scope', this.scope)\n        .set('provider', provider)\n        .set('external_token', external_token);\n\n      if (this.useHttpBasicAuth) {\n        const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n        headers = headers.set('Authorization', 'Basic ' + header);\n      }\n\n      if (!this.useHttpBasicAuth) {\n        params = params.set('client_id', this.clientId);\n      }\n\n      if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n        params = params.set('client_secret', this.dummyClientSecret);\n      }\n\n      if (this.customQueryParams) {\n        for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n          params = params.set(key, this.customQueryParams[key]);\n        }\n      }\n\n      headers = headers.set(\n        'Content-Type',\n        'application/x-www-form-urlencoded'\n      );\n\n      this.http\n        .post<TokenResponse>(this.tokenEndpoint, params, { headers })\n        .subscribe(\n          tokenResponse => {\n            this.debug('tokenResponse', tokenResponse);\n            this.storeAccessTokenResponse(\n              tokenResponse.access_token,\n              tokenResponse.refresh_token,\n              tokenResponse.expires_in,\n              tokenResponse.scope\n            );\n\n            this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n            resolve(tokenResponse);\n          },\n          err => {\n            this.logger.error('Error performing external token flow', err);\n            this.eventsSubject.next(new OAuthErrorEvent('token_error', err));\n            reject(err);\n          }\n        );\n    });\n  }\n\n  /**\n   * Uses password flow to exchange userName and password for an access_token.\n   * @param userName\n   * @param password\n   * @param headers Optional additional http-headers.\n   */\n  public fetchTokenUsingPasswordFlow(\n    userName: string,\n    password: string,\n    headers: HttpHeaders = new HttpHeaders()\n  ): Promise<TokenResponse> {\n    this.assertUrlNotNullAndCorrectProtocol(\n      this.tokenEndpoint,\n      'tokenEndpoint'\n    );\n\n    return new Promise((resolve, reject) => {\n      /**\n       * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to\n       * serialize and parse URL parameter keys and values.\n       *\n       * @stable\n       */\n      let params = new HttpParams({ encoder: new WebHttpUrlEncodingCodec() })\n        .set('grant_type', 'password')\n        .set('scope', this.scope)\n        .set('username', userName)\n        .set('password', password);\n\n      if (this.useHttpBasicAuth) {\n        const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n        headers = headers.set('Authorization', 'Basic ' + header);\n      }\n\n      if (!this.useHttpBasicAuth) {\n        params = params.set('client_id', this.clientId);\n      }\n\n      if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n        params = params.set('client_secret', this.dummyClientSecret);\n      }\n\n      if (this.customQueryParams) {\n        for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n          params = params.set(key, this.customQueryParams[key]);\n        }\n      }\n\n      headers = headers.set(\n        'Content-Type',\n        'application/x-www-form-urlencoded'\n      );\n\n      this.http\n        .post<TokenResponse>(this.tokenEndpoint, params, { headers })\n        .subscribe(\n          tokenResponse => {\n            this.debug('tokenResponse', tokenResponse);\n            this.storeAccessTokenResponse(\n              tokenResponse.access_token,\n              tokenResponse.refresh_token,\n              tokenResponse.expires_in,\n              tokenResponse.scope,\n              this.extractRecognizedCustomParameters(tokenResponse)\n            );\n\n            this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n            resolve(tokenResponse);\n          },\n          err => {\n            this.logger.error('Error performing password flow', err);\n            this.eventsSubject.next(new OAuthErrorEvent('token_error', err));\n            reject(err);\n          }\n        );\n    });\n  }\n\n  /**\n   * Refreshes the token using a refresh_token.\n   * This does not work for implicit flow, b/c\n   * there is no refresh_token in this flow.\n   * A solution for this is provided by the\n   * method silentRefresh.\n   */\n  public refreshToken(): Promise<TokenResponse> {\n    this.assertUrlNotNullAndCorrectProtocol(\n      this.tokenEndpoint,\n      'tokenEndpoint'\n    );\n\n    return new Promise((resolve, reject) => {\n      let params = new HttpParams()\n        .set('grant_type', 'refresh_token')\n        .set('scope', this.scope)\n        .set('refresh_token', this._storage.getItem('refresh_token'));\n\n      let headers = new HttpHeaders().set(\n        'Content-Type',\n        'application/x-www-form-urlencoded'\n      );\n\n      if (this.useHttpBasicAuth) {\n        const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n        headers = headers.set('Authorization', 'Basic ' + header);\n      }\n\n      if (!this.useHttpBasicAuth) {\n        params = params.set('client_id', this.clientId);\n      }\n\n      if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n        params = params.set('client_secret', this.dummyClientSecret);\n      }\n\n      if (this.customQueryParams) {\n        for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n          params = params.set(key, this.customQueryParams[key]);\n        }\n      }\n\n      this.http\n        .post<TokenResponse>(this.tokenEndpoint, params, { headers })\n        .pipe(\n          switchMap(tokenResponse => {\n            if (tokenResponse.id_token) {\n              return from(\n                this.processIdToken(\n                  tokenResponse.id_token,\n                  tokenResponse.access_token,\n                  true\n                )\n              ).pipe(\n                tap(result => this.storeIdToken(result)),\n                map(_ => tokenResponse)\n              );\n            } else {\n              return of(tokenResponse);\n            }\n          })\n        )\n        .subscribe(\n          tokenResponse => {\n            this.debug('refresh tokenResponse', tokenResponse);\n            this.storeAccessTokenResponse(\n              tokenResponse.access_token,\n              tokenResponse.refresh_token,\n              tokenResponse.expires_in,\n              tokenResponse.scope,\n              this.extractRecognizedCustomParameters(tokenResponse)\n            );\n\n            this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n            this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n            resolve(tokenResponse);\n          },\n          err => {\n            this.logger.error('Error refreshing token', err);\n            this.eventsSubject.next(\n              new OAuthErrorEvent('token_refresh_error', err)\n            );\n            reject(err);\n          }\n        );\n    });\n  }\n\n  protected removeSilentRefreshEventListener(): void {\n    if (this.silentRefreshPostMessageEventListener) {\n      window.removeEventListener(\n        'message',\n        this.silentRefreshPostMessageEventListener\n      );\n      this.silentRefreshPostMessageEventListener = null;\n    }\n  }\n\n  protected setupSilentRefreshEventListener(): void {\n    this.removeSilentRefreshEventListener();\n\n    this.silentRefreshPostMessageEventListener = (e: MessageEvent) => {\n      const message = this.processMessageEventMessage(e);\n\n      this.tryLogin({\n        customHashFragment: message,\n        preventClearHashAfterLogin: true,\n        customRedirectUri: this.silentRefreshRedirectUri || this.redirectUri\n      }).catch(err => this.debug('tryLogin during silent refresh failed', err));\n    };\n\n    window.addEventListener(\n      'message',\n      this.silentRefreshPostMessageEventListener\n    );\n  }\n\n  /**\n   * Performs a silent refresh for implicit flow.\n   * Use this method to get new tokens when/before\n   * the existing tokens expire.\n   */\n  public silentRefresh(\n    params: object = {},\n    noPrompt = true\n  ): Promise<OAuthEvent> {\n    const claims: object = this.getIdentityClaims() || {};\n\n    if (this.useIdTokenHintForSilentRefresh && this.hasValidIdToken()) {\n      params['id_token_hint'] = this.getIdToken();\n    }\n\n    if (!this.validateUrlForHttps(this.loginUrl)) {\n      throw new Error(\n        \"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\"\n      );\n    }\n\n    if (typeof document === 'undefined') {\n      throw new Error('silent refresh is not supported on this platform');\n    }\n\n    const existingIframe = document.getElementById(\n      this.silentRefreshIFrameName\n    );\n\n    if (existingIframe) {\n      document.body.removeChild(existingIframe);\n    }\n\n    this.silentRefreshSubject = claims['sub'];\n\n    const iframe = document.createElement('iframe');\n    iframe.id = this.silentRefreshIFrameName;\n\n    this.setupSilentRefreshEventListener();\n\n    const redirectUri = this.silentRefreshRedirectUri || this.redirectUri;\n    this.createLoginUrl(null, null, redirectUri, noPrompt, params).then(url => {\n      iframe.setAttribute('src', url);\n\n      if (!this.silentRefreshShowIFrame) {\n        iframe.style['display'] = 'none';\n      }\n      document.body.appendChild(iframe);\n    });\n\n    const errors = this.events.pipe(\n      filter(e => e instanceof OAuthErrorEvent),\n      first()\n    );\n    const success = this.events.pipe(\n      filter(e => e.type === 'token_received'),\n      first()\n    );\n    const timeout = of(\n      new OAuthErrorEvent('silent_refresh_timeout', null)\n    ).pipe(delay(this.silentRefreshTimeout));\n\n    return race([errors, success, timeout])\n      .pipe(\n        map(e => {\n          if (e instanceof OAuthErrorEvent) {\n            if (e.type === 'silent_refresh_timeout') {\n              this.eventsSubject.next(e);\n            } else {\n              e = new OAuthErrorEvent('silent_refresh_error', e);\n              this.eventsSubject.next(e);\n            }\n            throw e;\n          } else if (e.type === 'token_received') {\n            e = new OAuthSuccessEvent('silently_refreshed');\n            this.eventsSubject.next(e);\n          }\n          return e;\n        })\n      )\n      .toPromise();\n  }\n\n  /**\n   * This method exists for backwards compatibility.\n   * {@link OAuthService#initLoginFlowInPopup} handles both code\n   * and implicit flows.\n   */\n  public initImplicitFlowInPopup(options?: {\n    height?: number;\n    width?: number;\n  }) {\n    return this.initLoginFlowInPopup(options);\n  }\n\n  public initLoginFlowInPopup(options?: { height?: number; width?: number }) {\n    options = options || {};\n    return this.createLoginUrl(\n      null,\n      null,\n      this.silentRefreshRedirectUri,\n      false,\n      {\n        display: 'popup'\n      }\n    ).then(url => {\n      return new Promise((resolve, reject) => {\n        /**\n         * Error handling section\n         */\n        const checkForPopupClosedInterval = 500;\n        let windowRef = window.open(\n          url,\n          '_blank',\n          this.calculatePopupFeatures(options)\n        );\n        let checkForPopupClosedTimer: any;\n        const checkForPopupClosed = () => {\n          if (!windowRef || windowRef.closed) {\n            cleanup();\n            reject(new OAuthErrorEvent('popup_closed', {}));\n          }\n        };\n        if (!windowRef) {\n          reject(new OAuthErrorEvent('popup_blocked', {}));\n        } else {\n          checkForPopupClosedTimer = window.setInterval(\n            checkForPopupClosed,\n            checkForPopupClosedInterval\n          );\n        }\n\n        const cleanup = () => {\n          window.clearInterval(checkForPopupClosedTimer);\n          window.removeEventListener('message', listener);\n          if (windowRef !== null) {\n            windowRef.close();\n          }\n          windowRef = null;\n        };\n\n        const listener = (e: MessageEvent) => {\n          const message = this.processMessageEventMessage(e);\n\n          if (message && message !== null) {\n            this.tryLogin({\n              customHashFragment: message,\n              preventClearHashAfterLogin: true,\n              customRedirectUri: this.silentRefreshRedirectUri\n            }).then(\n              () => {\n                cleanup();\n                resolve();\n              },\n              err => {\n                cleanup();\n                reject(err);\n              }\n            );\n          } else {\n            console.log('false event firing');\n          }\n        };\n\n        window.addEventListener('message', listener);\n      });\n    });\n  }\n\n  protected calculatePopupFeatures(options: {\n    height?: number;\n    width?: number;\n  }): string {\n    // Specify an static height and width and calculate centered position\n\n    const height = options.height || 470;\n    const width = options.width || 500;\n    const left = window.screenLeft + (window.outerWidth - width) / 2;\n    const top = window.screenTop + (window.outerHeight - height) / 2;\n    return `location=no,toolbar=no,width=${width},height=${height},top=${top},left=${left}`;\n  }\n\n  protected processMessageEventMessage(e: MessageEvent): string {\n    let expectedPrefix = '#';\n\n    if (this.silentRefreshMessagePrefix) {\n      expectedPrefix += this.silentRefreshMessagePrefix;\n    }\n\n    if (!e || !e.data || typeof e.data !== 'string') {\n      return;\n    }\n\n    const prefixedMessage: string = e.data;\n\n    if (!prefixedMessage.startsWith(expectedPrefix)) {\n      return;\n    }\n\n    return '#' + prefixedMessage.substr(expectedPrefix.length);\n  }\n\n  protected canPerformSessionCheck(): boolean {\n    if (!this.sessionChecksEnabled) {\n      return false;\n    }\n    if (!this.sessionCheckIFrameUrl) {\n      console.warn(\n        'sessionChecksEnabled is activated but there is no sessionCheckIFrameUrl'\n      );\n      return false;\n    }\n    const sessionState = this.getSessionState();\n    if (!sessionState) {\n      console.warn(\n        'sessionChecksEnabled is activated but there is no session_state'\n      );\n      return false;\n    }\n    if (typeof document === 'undefined') {\n      return false;\n    }\n\n    return true;\n  }\n\n  protected setupSessionCheckEventListener(): void {\n    this.removeSessionCheckEventListener();\n\n    this.sessionCheckEventListener = (e: MessageEvent) => {\n      const origin = e.origin.toLowerCase();\n      const issuer = this.issuer.toLowerCase();\n\n      this.debug('sessionCheckEventListener');\n\n      if (!issuer.startsWith(origin)) {\n        this.debug(\n          'sessionCheckEventListener',\n          'wrong origin',\n          origin,\n          'expected',\n          issuer,\n          'event',\n          e\n        );\n\n        return;\n      }\n\n      // only run in Angular zone if it is 'changed' or 'error'\n      switch (e.data) {\n        case 'unchanged':\n          this.handleSessionUnchanged();\n          break;\n        case 'changed':\n          this.ngZone.run(() => {\n            this.handleSessionChange();\n          });\n          break;\n        case 'error':\n          this.ngZone.run(() => {\n            this.handleSessionError();\n          });\n          break;\n      }\n\n      this.debug('got info from session check inframe', e);\n    };\n\n    // prevent Angular from refreshing the view on every message (runs in intervals)\n    this.ngZone.runOutsideAngular(() => {\n      window.addEventListener('message', this.sessionCheckEventListener);\n    });\n  }\n\n  protected handleSessionUnchanged(): void {\n    this.debug('session check', 'session unchanged');\n  }\n\n  protected handleSessionChange(): void {\n    this.eventsSubject.next(new OAuthInfoEvent('session_changed'));\n    this.stopSessionCheckTimer();\n\n    if (!this.useSilentRefresh && this.responseType === 'code') {\n      this.refreshToken()\n        .then(_ => {\n          this.debug('token refresh after session change worked');\n        })\n        .catch(_ => {\n          this.debug('token refresh did not work after session changed');\n          this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n          this.logOut(true);\n        });\n    } else if (this.silentRefreshRedirectUri) {\n      this.silentRefresh().catch(_ =>\n        this.debug('silent refresh failed after session changed')\n      );\n      this.waitForSilentRefreshAfterSessionChange();\n    } else {\n      this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n      this.logOut(true);\n    }\n  }\n\n  protected waitForSilentRefreshAfterSessionChange(): void {\n    this.events\n      .pipe(\n        filter(\n          (e: OAuthEvent) =>\n            e.type === 'silently_refreshed' ||\n            e.type === 'silent_refresh_timeout' ||\n            e.type === 'silent_refresh_error'\n        ),\n        first()\n      )\n      .subscribe(e => {\n        if (e.type !== 'silently_refreshed') {\n          this.debug('silent refresh did not work after session changed');\n          this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n          this.logOut(true);\n        }\n      });\n  }\n\n  protected handleSessionError(): void {\n    this.stopSessionCheckTimer();\n    this.eventsSubject.next(new OAuthInfoEvent('session_error'));\n  }\n\n  protected removeSessionCheckEventListener(): void {\n    if (this.sessionCheckEventListener) {\n      window.removeEventListener('message', this.sessionCheckEventListener);\n      this.sessionCheckEventListener = null;\n    }\n  }\n\n  protected initSessionCheck(): void {\n    if (!this.canPerformSessionCheck()) {\n      return;\n    }\n\n    const existingIframe = document.getElementById(this.sessionCheckIFrameName);\n    if (existingIframe) {\n      document.body.removeChild(existingIframe);\n    }\n\n    const iframe = document.createElement('iframe');\n    iframe.id = this.sessionCheckIFrameName;\n\n    this.setupSessionCheckEventListener();\n\n    const url = this.sessionCheckIFrameUrl;\n    iframe.setAttribute('src', url);\n    iframe.style.display = 'none';\n    document.body.appendChild(iframe);\n\n    this.startSessionCheckTimer();\n  }\n\n  protected startSessionCheckTimer(): void {\n    this.stopSessionCheckTimer();\n    this.ngZone.runOutsideAngular(() => {\n      this.sessionCheckTimer = setInterval(\n        this.checkSession.bind(this),\n        this.sessionCheckIntervall\n      );\n    });\n  }\n\n  protected stopSessionCheckTimer(): void {\n    if (this.sessionCheckTimer) {\n      clearInterval(this.sessionCheckTimer);\n      this.sessionCheckTimer = null;\n    }\n  }\n\n  public checkSession(): void {\n    const iframe: any = document.getElementById(this.sessionCheckIFrameName);\n\n    if (!iframe) {\n      this.logger.warn(\n        'checkSession did not find iframe',\n        this.sessionCheckIFrameName\n      );\n    }\n\n    const sessionState = this.getSessionState();\n\n    if (!sessionState) {\n      this.stopSessionCheckTimer();\n    }\n\n    const message = this.clientId + ' ' + sessionState;\n    iframe.contentWindow.postMessage(message, this.issuer);\n  }\n\n  protected async createLoginUrl(\n    state = '',\n    loginHint = '',\n    customRedirectUri = '',\n    noPrompt = false,\n    params: object = {}\n  ): Promise<string> {\n    const that = this;\n\n    let redirectUri: string;\n\n    if (customRedirectUri) {\n      redirectUri = customRedirectUri;\n    } else {\n      redirectUri = this.redirectUri;\n    }\n\n    const nonce = await this.createAndSaveNonce();\n\n    if (state) {\n      state =\n        nonce + this.config.nonceStateSeparator + encodeURIComponent(state);\n    } else {\n      state = nonce;\n    }\n\n    if (!this.requestAccessToken && !this.oidc) {\n      throw new Error('Either requestAccessToken or oidc or both must be true');\n    }\n\n    if (this.config.responseType) {\n      this.responseType = this.config.responseType;\n    } else {\n      if (this.oidc && this.requestAccessToken) {\n        this.responseType = 'id_token token';\n      } else if (this.oidc && !this.requestAccessToken) {\n        this.responseType = 'id_token';\n      } else {\n        this.responseType = 'token';\n      }\n    }\n\n    const seperationChar = that.loginUrl.indexOf('?') > -1 ? '&' : '?';\n\n    let scope = that.scope;\n\n    if (this.oidc && !scope.match(/(^|\\s)openid($|\\s)/)) {\n      scope = 'openid ' + scope;\n    }\n\n    let url =\n      that.loginUrl +\n      seperationChar +\n      'response_type=' +\n      encodeURIComponent(that.responseType) +\n      '&client_id=' +\n      encodeURIComponent(that.clientId) +\n      '&state=' +\n      encodeURIComponent(state) +\n      '&redirect_uri=' +\n      encodeURIComponent(redirectUri) +\n      '&scope=' +\n      encodeURIComponent(scope);\n\n    if (this.responseType === 'code' && !this.disablePKCE) {\n      const [\n        challenge,\n        verifier\n      ] = await this.createChallangeVerifierPairForPKCE();\n\n      if (\n        this.saveNoncesInLocalStorage &&\n        typeof window['localStorage'] !== 'undefined'\n      ) {\n        localStorage.setItem('PKCI_verifier', verifier);\n      } else {\n        this._storage.setItem('PKCI_verifier', verifier);\n      }\n\n      url += '&code_challenge=' + challenge;\n      url += '&code_challenge_method=S256';\n    }\n\n    if (loginHint) {\n      url += '&login_hint=' + encodeURIComponent(loginHint);\n    }\n\n    if (that.resource) {\n      url += '&resource=' + encodeURIComponent(that.resource);\n    }\n\n    if (that.oidc) {\n      url += '&nonce=' + encodeURIComponent(nonce);\n    }\n\n    if (noPrompt) {\n      url += '&prompt=none';\n    }\n\n    for (const key of Object.keys(params)) {\n      url +=\n        '&' + encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n    }\n\n    if (this.customQueryParams) {\n      for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n        url +=\n          '&' + key + '=' + encodeURIComponent(this.customQueryParams[key]);\n      }\n    }\n\n    return url;\n  }\n\n  initImplicitFlowInternal(\n    additionalState = '',\n    params: string | object = ''\n  ): void {\n    if (this.inImplicitFlow) {\n      return;\n    }\n\n    this.inImplicitFlow = true;\n\n    if (!this.validateUrlForHttps(this.loginUrl)) {\n      throw new Error(\n        \"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\"\n      );\n    }\n\n    let addParams: object = {};\n    let loginHint: string = null;\n\n    if (typeof params === 'string') {\n      loginHint = params;\n    } else if (typeof params === 'object') {\n      addParams = params;\n    }\n\n    this.createLoginUrl(additionalState, loginHint, null, false, addParams)\n      .then(this.config.openUri)\n      .catch(error => {\n        console.error('Error in initImplicitFlow', error);\n        this.inImplicitFlow = false;\n      });\n  }\n\n  /**\n   * Starts the implicit flow and redirects to user to\n   * the auth servers' login url.\n   *\n   * @param additionalState Optional state that is passed around.\n   *  You'll find this state in the property `state` after `tryLogin` logged in the user.\n   * @param params Hash with additional parameter. If it is a string, it is used for the\n   *               parameter loginHint (for the sake of compatibility with former versions)\n   */\n  public initImplicitFlow(\n    additionalState = '',\n    params: string | object = ''\n  ): void {\n    if (this.loginUrl !== '') {\n      this.initImplicitFlowInternal(additionalState, params);\n    } else {\n      this.events\n        .pipe(filter(e => e.type === 'discovery_document_loaded'))\n        .subscribe(_ => this.initImplicitFlowInternal(additionalState, params));\n    }\n  }\n\n  /**\n   * Reset current implicit flow\n   *\n   * @description This method allows resetting the current implict flow in order to be initialized again.\n   */\n  public resetImplicitFlow(): void {\n    this.inImplicitFlow = false;\n  }\n\n  protected callOnTokenReceivedIfExists(options: LoginOptions): void {\n    const that = this;\n    if (options.onTokenReceived) {\n      const tokenParams = {\n        idClaims: that.getIdentityClaims(),\n        idToken: that.getIdToken(),\n        accessToken: that.getAccessToken(),\n        state: that.state\n      };\n      options.onTokenReceived(tokenParams);\n    }\n  }\n\n  protected storeAccessTokenResponse(\n    accessToken: string,\n    refreshToken: string,\n    expiresIn: number,\n    grantedScopes: String,\n    customParameters?: Map<string, string>\n  ): void {\n    this._storage.setItem('access_token', accessToken);\n    if (grantedScopes && !Array.isArray(grantedScopes)) {\n      this._storage.setItem(\n        'granted_scopes',\n        JSON.stringify(grantedScopes.split('+'))\n      );\n    } else if (grantedScopes && Array.isArray(grantedScopes)) {\n      this._storage.setItem('granted_scopes', JSON.stringify(grantedScopes));\n    }\n\n    this._storage.setItem('access_token_stored_at', '' + Date.now());\n    if (expiresIn) {\n      const expiresInMilliSeconds = expiresIn * 1000;\n      const now = new Date();\n      const expiresAt = now.getTime() + expiresInMilliSeconds;\n      this._storage.setItem('expires_at', '' + expiresAt);\n    }\n\n    if (refreshToken) {\n      this._storage.setItem('refresh_token', refreshToken);\n    }\n    if (customParameters) {\n      customParameters.forEach((value: string, key: string) => {\n        this._storage.setItem(key, value);\n      });\n    }\n  }\n\n  /**\n   * Delegates to tryLoginImplicitFlow for the sake of competability\n   * @param options Optional options.\n   */\n  public tryLogin(options: LoginOptions = null): Promise<boolean> {\n    if (this.config.responseType === 'code') {\n      return this.tryLoginCodeFlow(options).then(_ => true);\n    } else {\n      return this.tryLoginImplicitFlow(options);\n    }\n  }\n\n  private parseQueryString(queryString: string): object {\n    if (!queryString || queryString.length === 0) {\n      return {};\n    }\n\n    if (queryString.charAt(0) === '?') {\n      queryString = queryString.substr(1);\n    }\n\n    return this.urlHelper.parseQueryString(queryString);\n  }\n\n  public tryLoginCodeFlow(options: LoginOptions = null): Promise<void> {\n    options = options || {};\n\n    const querySource = options.customHashFragment\n      ? options.customHashFragment.substring(1)\n      : window.location.search;\n\n    const parts = this.getCodePartsFromUrl(querySource);\n\n    const code = parts['code'];\n    const state = parts['state'];\n\n    const sessionState = parts['session_state'];\n\n    if (!options.preventClearHashAfterLogin) {\n      const href = location.href\n        .replace(/[&\\?]code=[^&\\$]*/, '')\n        .replace(/[&\\?]scope=[^&\\$]*/, '')\n        .replace(/[&\\?]state=[^&\\$]*/, '')\n        .replace(/[&\\?]session_state=[^&\\$]*/, '');\n\n      history.replaceState(null, window.name, href);\n    }\n\n    let [nonceInState, userState] = this.parseState(state);\n    this.state = userState;\n\n    if (parts['error']) {\n      this.debug('error trying to login');\n      this.handleLoginError({}, parts);\n      const err = new OAuthErrorEvent('code_error', {}, parts);\n      this.eventsSubject.next(err);\n      return Promise.reject(err);\n    }\n\n    if (!nonceInState) {\n      return Promise.resolve();\n    }\n\n    const success = this.validateNonce(nonceInState);\n    if (!success) {\n      const event = new OAuthErrorEvent('invalid_nonce_in_state', null);\n      this.eventsSubject.next(event);\n      return Promise.reject(event);\n    }\n\n    this.storeSessionState(sessionState);\n\n    if (code) {\n      return this.getTokenFromCode(code, options).then(_ => null);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  /**\n   * Retrieve the returned auth code from the redirect uri that has been called.\n   * If required also check hash, as we could use hash location strategy.\n   */\n  private getCodePartsFromUrl(queryString: string): object {\n    if (!queryString || queryString.length === 0) {\n      return this.urlHelper.getHashFragmentParams();\n    }\n\n    // normalize query string\n    if (queryString.charAt(0) === '?') {\n      queryString = queryString.substr(1);\n    }\n\n    return this.urlHelper.parseQueryString(queryString);\n  }\n\n  /**\n   * Get token using an intermediate code. Works for the Authorization Code flow.\n   */\n  private getTokenFromCode(\n    code: string,\n    options: LoginOptions\n  ): Promise<object> {\n    let params = new HttpParams()\n      .set('grant_type', 'authorization_code')\n      .set('code', code)\n      .set('redirect_uri', options.customRedirectUri || this.redirectUri);\n\n    if (!this.disablePKCE) {\n      let pkciVerifier;\n\n      if (\n        this.saveNoncesInLocalStorage &&\n        typeof window['localStorage'] !== 'undefined'\n      ) {\n        pkciVerifier = localStorage.getItem('PKCI_verifier');\n      } else {\n        pkciVerifier = this._storage.getItem('PKCI_verifier');\n      }\n\n      if (!pkciVerifier) {\n        console.warn('No PKCI verifier found in oauth storage!');\n      } else {\n        params = params.set('code_verifier', pkciVerifier);\n      }\n    }\n\n    return this.fetchAndProcessToken(params);\n  }\n\n  private fetchAndProcessToken(params: HttpParams): Promise<TokenResponse> {\n    this.assertUrlNotNullAndCorrectProtocol(\n      this.tokenEndpoint,\n      'tokenEndpoint'\n    );\n    let headers = new HttpHeaders().set(\n      'Content-Type',\n      'application/x-www-form-urlencoded'\n    );\n\n    if (this.useHttpBasicAuth) {\n      const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n      headers = headers.set('Authorization', 'Basic ' + header);\n    }\n\n    if (!this.useHttpBasicAuth) {\n      params = params.set('client_id', this.clientId);\n    }\n\n    if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n      params = params.set('client_secret', this.dummyClientSecret);\n    }\n\n    return new Promise((resolve, reject) => {\n      if (this.customQueryParams) {\n        for (let key of Object.getOwnPropertyNames(this.customQueryParams)) {\n          params = params.set(key, this.customQueryParams[key]);\n        }\n      }\n\n      this.http\n        .post<TokenResponse>(this.tokenEndpoint, params, { headers })\n        .subscribe(\n          tokenResponse => {\n            this.debug('refresh tokenResponse', tokenResponse);\n            this.storeAccessTokenResponse(\n              tokenResponse.access_token,\n              tokenResponse.refresh_token,\n              tokenResponse.expires_in,\n              tokenResponse.scope,\n              this.extractRecognizedCustomParameters(tokenResponse)\n            );\n\n            if (this.oidc && tokenResponse.id_token) {\n              this.processIdToken(\n                tokenResponse.id_token,\n                tokenResponse.access_token\n              )\n                .then(result => {\n                  this.storeIdToken(result);\n\n                  this.eventsSubject.next(\n                    new OAuthSuccessEvent('token_received')\n                  );\n                  this.eventsSubject.next(\n                    new OAuthSuccessEvent('token_refreshed')\n                  );\n\n                  resolve(tokenResponse);\n                })\n                .catch(reason => {\n                  this.eventsSubject.next(\n                    new OAuthErrorEvent('token_validation_error', reason)\n                  );\n                  console.error('Error validating tokens');\n                  console.error(reason);\n\n                  reject(reason);\n                });\n            } else {\n              this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n              this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n\n              resolve(tokenResponse);\n            }\n          },\n          err => {\n            console.error('Error getting token', err);\n            this.eventsSubject.next(\n              new OAuthErrorEvent('token_refresh_error', err)\n            );\n            reject(err);\n          }\n        );\n    });\n  }\n\n  /**\n   * Checks whether there are tokens in the hash fragment\n   * as a result of the implicit flow. These tokens are\n   * parsed, validated and used to sign the user in to the\n   * current client.\n   *\n   * @param options Optional options.\n   */\n  public tryLoginImplicitFlow(options: LoginOptions = null): Promise<boolean> {\n    options = options || {};\n\n    let parts: object;\n\n    if (options.customHashFragment) {\n      parts = this.urlHelper.getHashFragmentParams(options.customHashFragment);\n    } else {\n      parts = this.urlHelper.getHashFragmentParams();\n    }\n\n    this.debug('parsed url', parts);\n\n    const state = parts['state'];\n\n    let [nonceInState, userState] = this.parseState(state);\n    this.state = userState;\n\n    if (parts['error']) {\n      this.debug('error trying to login');\n      this.handleLoginError(options, parts);\n      const err = new OAuthErrorEvent('token_error', {}, parts);\n      this.eventsSubject.next(err);\n      return Promise.reject(err);\n    }\n\n    const accessToken = parts['access_token'];\n    const idToken = parts['id_token'];\n    const sessionState = parts['session_state'];\n    const grantedScopes = parts['scope'];\n\n    if (!this.requestAccessToken && !this.oidc) {\n      return Promise.reject(\n        'Either requestAccessToken or oidc (or both) must be true.'\n      );\n    }\n\n    if (this.requestAccessToken && !accessToken) {\n      return Promise.resolve(false);\n    }\n    if (this.requestAccessToken && !options.disableOAuth2StateCheck && !state) {\n      return Promise.resolve(false);\n    }\n    if (this.oidc && !idToken) {\n      return Promise.resolve(false);\n    }\n\n    if (this.sessionChecksEnabled && !sessionState) {\n      this.logger.warn(\n        'session checks (Session Status Change Notification) ' +\n          'were activated in the configuration but the id_token ' +\n          'does not contain a session_state claim'\n      );\n    }\n\n    if (this.requestAccessToken && !options.disableOAuth2StateCheck) {\n      const success = this.validateNonce(nonceInState);\n\n      if (!success) {\n        const event = new OAuthErrorEvent('invalid_nonce_in_state', null);\n        this.eventsSubject.next(event);\n        return Promise.reject(event);\n      }\n    }\n\n    if (this.requestAccessToken) {\n      this.storeAccessTokenResponse(\n        accessToken,\n        null,\n        parts['expires_in'] || this.fallbackAccessTokenExpirationTimeInSec,\n        grantedScopes\n      );\n    }\n\n    if (!this.oidc) {\n      this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n      if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n        location.hash = '';\n      }\n\n      this.callOnTokenReceivedIfExists(options);\n      return Promise.resolve(true);\n    }\n\n    return this.processIdToken(idToken, accessToken)\n      .then(result => {\n        if (options.validationHandler) {\n          return options\n            .validationHandler({\n              accessToken: accessToken,\n              idClaims: result.idTokenClaims,\n              idToken: result.idToken,\n              state: state\n            })\n            .then(_ => result);\n        }\n        return result;\n      })\n      .then(result => {\n        this.storeIdToken(result);\n        this.storeSessionState(sessionState);\n        if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n          location.hash = '';\n        }\n        this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n        this.callOnTokenReceivedIfExists(options);\n        this.inImplicitFlow = false;\n        return true;\n      })\n      .catch(reason => {\n        this.eventsSubject.next(\n          new OAuthErrorEvent('token_validation_error', reason)\n        );\n        this.logger.error('Error validating tokens');\n        this.logger.error(reason);\n        return Promise.reject(reason);\n      });\n  }\n\n  private parseState(state: string): [string, string] {\n    let nonce = state;\n    let userState = '';\n\n    if (state) {\n      const idx = state.indexOf(this.config.nonceStateSeparator);\n      if (idx > -1) {\n        nonce = state.substr(0, idx);\n        userState = state.substr(idx + this.config.nonceStateSeparator.length);\n      }\n    }\n    return [nonce, userState];\n  }\n\n  protected validateNonce(nonceInState: string): boolean {\n    let savedNonce;\n\n    if (\n      this.saveNoncesInLocalStorage &&\n      typeof window['localStorage'] !== 'undefined'\n    ) {\n      savedNonce = localStorage.getItem('nonce');\n    } else {\n      savedNonce = this._storage.getItem('nonce');\n    }\n\n    if (savedNonce !== nonceInState) {\n      const err = 'Validating access_token failed, wrong state/nonce.';\n      console.error(err, savedNonce, nonceInState);\n      return false;\n    }\n    return true;\n  }\n\n  protected storeIdToken(idToken: ParsedIdToken): void {\n    this._storage.setItem('id_token', idToken.idToken);\n    this._storage.setItem('id_token_claims_obj', idToken.idTokenClaimsJson);\n    this._storage.setItem('id_token_expires_at', '' + idToken.idTokenExpiresAt);\n    this._storage.setItem('id_token_stored_at', '' + Date.now());\n  }\n\n  protected storeSessionState(sessionState: string): void {\n    this._storage.setItem('session_state', sessionState);\n  }\n\n  protected getSessionState(): string {\n    return this._storage.getItem('session_state');\n  }\n\n  protected handleLoginError(options: LoginOptions, parts: object): void {\n    if (options.onLoginError) {\n      options.onLoginError(parts);\n    }\n    if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n      location.hash = '';\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  public processIdToken(\n    idToken: string,\n    accessToken: string,\n    skipNonceCheck = false\n  ): Promise<ParsedIdToken> {\n    const tokenParts = idToken.split('.');\n    const headerBase64 = this.padBase64(tokenParts[0]);\n    const headerJson = b64DecodeUnicode(headerBase64);\n    const header = JSON.parse(headerJson);\n    const claimsBase64 = this.padBase64(tokenParts[1]);\n    const claimsJson = b64DecodeUnicode(claimsBase64);\n    const claims = JSON.parse(claimsJson);\n\n    let savedNonce;\n    if (\n      this.saveNoncesInLocalStorage &&\n      typeof window['localStorage'] !== 'undefined'\n    ) {\n      savedNonce = localStorage.getItem('nonce');\n    } else {\n      savedNonce = this._storage.getItem('nonce');\n    }\n\n    if (Array.isArray(claims.aud)) {\n      if (claims.aud.every(v => v !== this.clientId)) {\n        const err = 'Wrong audience: ' + claims.aud.join(',');\n        this.logger.warn(err);\n        return Promise.reject(err);\n      }\n    } else {\n      if (claims.aud !== this.clientId) {\n        const err = 'Wrong audience: ' + claims.aud;\n        this.logger.warn(err);\n        return Promise.reject(err);\n      }\n    }\n\n    if (!claims.sub) {\n      const err = 'No sub claim in id_token';\n      this.logger.warn(err);\n      return Promise.reject(err);\n    }\n\n    /* For now, we only check whether the sub against\n     * silentRefreshSubject when sessionChecksEnabled is on\n     * We will reconsider in a later version to do this\n     * in every other case too.\n     */\n    if (\n      this.sessionChecksEnabled &&\n      this.silentRefreshSubject &&\n      this.silentRefreshSubject !== claims['sub']\n    ) {\n      const err =\n        'After refreshing, we got an id_token for another user (sub). ' +\n        `Expected sub: ${this.silentRefreshSubject}, received sub: ${claims['sub']}`;\n\n      this.logger.warn(err);\n      return Promise.reject(err);\n    }\n\n    if (!claims.iat) {\n      const err = 'No iat claim in id_token';\n      this.logger.warn(err);\n      return Promise.reject(err);\n    }\n\n    if (!this.skipIssuerCheck && claims.iss !== this.issuer) {\n      const err = 'Wrong issuer: ' + claims.iss;\n      this.logger.warn(err);\n      return Promise.reject(err);\n    }\n\n    if (!skipNonceCheck && claims.nonce !== savedNonce) {\n      const err = 'Wrong nonce: ' + claims.nonce;\n      this.logger.warn(err);\n      return Promise.reject(err);\n    }\n    // at_hash is not applicable to authorization code flow\n    // addressing https://github.com/manfredsteyer/angular-oauth2-oidc/issues/661\n    // i.e. Based on spec the at_hash check is only true for implicit code flow on Ping Federate\n    // https://www.pingidentity.com/developer/en/resources/openid-connect-developers-guide.html\n    if (this.hasOwnProperty('responseType') && this.responseType === 'code') {\n      this.disableAtHashCheck = true;\n    }\n    if (\n      !this.disableAtHashCheck &&\n      this.requestAccessToken &&\n      !claims['at_hash']\n    ) {\n      const err = 'An at_hash is needed!';\n      this.logger.warn(err);\n      return Promise.reject(err);\n    }\n\n    const now = Date.now();\n    const issuedAtMSec = claims.iat * 1000;\n    const expiresAtMSec = claims.exp * 1000;\n    const clockSkewInMSec = (this.clockSkewInSec || 600) * 1000;\n\n    if (\n      issuedAtMSec - clockSkewInMSec >= now ||\n      expiresAtMSec + clockSkewInMSec <= now\n    ) {\n      const err = 'Token has expired';\n      console.error(err);\n      console.error({\n        now: now,\n        issuedAtMSec: issuedAtMSec,\n        expiresAtMSec: expiresAtMSec\n      });\n      return Promise.reject(err);\n    }\n\n    const validationParams: ValidationParams = {\n      accessToken: accessToken,\n      idToken: idToken,\n      jwks: this.jwks,\n      idTokenClaims: claims,\n      idTokenHeader: header,\n      loadKeys: () => this.loadJwks()\n    };\n\n    if (this.disableAtHashCheck) {\n      return this.checkSignature(validationParams).then(_ => {\n        const result: ParsedIdToken = {\n          idToken: idToken,\n          idTokenClaims: claims,\n          idTokenClaimsJson: claimsJson,\n          idTokenHeader: header,\n          idTokenHeaderJson: headerJson,\n          idTokenExpiresAt: expiresAtMSec\n        };\n        return result;\n      });\n    }\n\n    return this.checkAtHash(validationParams).then(atHashValid => {\n      if (!this.disableAtHashCheck && this.requestAccessToken && !atHashValid) {\n        const err = 'Wrong at_hash';\n        this.logger.warn(err);\n        return Promise.reject(err);\n      }\n\n      return this.checkSignature(validationParams).then(_ => {\n        const atHashCheckEnabled = !this.disableAtHashCheck;\n        const result: ParsedIdToken = {\n          idToken: idToken,\n          idTokenClaims: claims,\n          idTokenClaimsJson: claimsJson,\n          idTokenHeader: header,\n          idTokenHeaderJson: headerJson,\n          idTokenExpiresAt: expiresAtMSec\n        };\n        if (atHashCheckEnabled) {\n          return this.checkAtHash(validationParams).then(atHashValid => {\n            if (this.requestAccessToken && !atHashValid) {\n              const err = 'Wrong at_hash';\n              this.logger.warn(err);\n              return Promise.reject(err);\n            } else {\n              return result;\n            }\n          });\n        } else {\n          return result;\n        }\n      });\n    });\n  }\n\n  /**\n   * Returns the received claims about the user.\n   */\n  public getIdentityClaims(): object {\n    const claims = this._storage.getItem('id_token_claims_obj');\n    if (!claims) {\n      return null;\n    }\n    return JSON.parse(claims);\n  }\n\n  /**\n   * Returns the granted scopes from the server.\n   */\n  public getGrantedScopes(): object {\n    const scopes = this._storage.getItem('granted_scopes');\n    if (!scopes) {\n      return null;\n    }\n    return JSON.parse(scopes);\n  }\n\n  /**\n   * Returns the current id_token.\n   */\n  public getIdToken(): string {\n    return this._storage ? this._storage.getItem('id_token') : null;\n  }\n\n  protected padBase64(base64data): string {\n    while (base64data.length % 4 !== 0) {\n      base64data += '=';\n    }\n    return base64data;\n  }\n\n  /**\n   * Returns the current access_token.\n   */\n  public getAccessToken(): string {\n    return this._storage ? this._storage.getItem('access_token') : null;\n  }\n\n  public getRefreshToken(): string {\n    return this._storage ? this._storage.getItem('refresh_token') : null;\n  }\n\n  /**\n   * Returns the expiration date of the access_token\n   * as milliseconds since 1970.\n   */\n  public getAccessTokenExpiration(): number {\n    if (!this._storage.getItem('expires_at')) {\n      return null;\n    }\n    return parseInt(this._storage.getItem('expires_at'), 10);\n  }\n\n  protected getAccessTokenStoredAt(): number {\n    return parseInt(this._storage.getItem('access_token_stored_at'), 10);\n  }\n\n  protected getIdTokenStoredAt(): number {\n    return parseInt(this._storage.getItem('id_token_stored_at'), 10);\n  }\n\n  /**\n   * Returns the expiration date of the id_token\n   * as milliseconds since 1970.\n   */\n  public getIdTokenExpiration(): number {\n    if (!this._storage.getItem('id_token_expires_at')) {\n      return null;\n    }\n\n    return parseInt(this._storage.getItem('id_token_expires_at'), 10);\n  }\n\n  /**\n   * Checkes, whether there is a valid access_token.\n   */\n  public hasValidAccessToken(): boolean {\n    if (this.getAccessToken()) {\n      const expiresAt = this._storage.getItem('expires_at');\n      const now = new Date();\n      if (expiresAt && parseInt(expiresAt, 10) < now.getTime()) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Checks whether there is a valid id_token.\n   */\n  public hasValidIdToken(): boolean {\n    if (this.getIdToken()) {\n      const expiresAt = this._storage.getItem('id_token_expires_at');\n      const now = new Date();\n      if (expiresAt && parseInt(expiresAt, 10) < now.getTime()) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Retrieve a saved custom property of the TokenReponse object. Only if predefined in authconfig.\n   */\n  public getCustomTokenResponseProperty(requestedProperty: string): any {\n    return this._storage &&\n      this.config.customTokenParameters &&\n      this.config.customTokenParameters.indexOf(requestedProperty) >= 0 &&\n      this._storage.getItem(requestedProperty) !== null\n      ? JSON.parse(this._storage.getItem(requestedProperty))\n      : null;\n  }\n\n  /**\n   * Returns the auth-header that can be used\n   * to transmit the access_token to a service\n   */\n  public authorizationHeader(): string {\n    return 'Bearer ' + this.getAccessToken();\n  }\n\n  /**\n   * Removes all tokens and logs the user out.\n   * If a logout url is configured, the user is\n   * redirected to it with optional state parameter.\n   * @param noRedirectToLogoutUrl\n   * @param state\n   */\n  public logOut(noRedirectToLogoutUrl = false, state = ''): void {\n    const id_token = this.getIdToken();\n    this._storage.removeItem('access_token');\n    this._storage.removeItem('id_token');\n    this._storage.removeItem('refresh_token');\n\n    if (this.saveNoncesInLocalStorage) {\n      localStorage.removeItem('nonce');\n      localStorage.removeItem('PKCI_verifier');\n    } else {\n      this._storage.removeItem('nonce');\n      this._storage.removeItem('PKCI_verifier');\n    }\n\n    this._storage.removeItem('expires_at');\n    this._storage.removeItem('id_token_claims_obj');\n    this._storage.removeItem('id_token_expires_at');\n    this._storage.removeItem('id_token_stored_at');\n    this._storage.removeItem('access_token_stored_at');\n    this._storage.removeItem('granted_scopes');\n    this._storage.removeItem('session_state');\n    if (this.config.customTokenParameters) {\n      this.config.customTokenParameters.forEach(customParam =>\n        this._storage.removeItem(customParam)\n      );\n    }\n    this.silentRefreshSubject = null;\n\n    this.eventsSubject.next(new OAuthInfoEvent('logout'));\n\n    if (!this.logoutUrl) {\n      return;\n    }\n    if (noRedirectToLogoutUrl) {\n      return;\n    }\n\n    if (!id_token && !this.postLogoutRedirectUri) {\n      return;\n    }\n\n    let logoutUrl: string;\n\n    if (!this.validateUrlForHttps(this.logoutUrl)) {\n      throw new Error(\n        \"logoutUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\"\n      );\n    }\n\n    // For backward compatibility\n    if (this.logoutUrl.indexOf('{{') > -1) {\n      logoutUrl = this.logoutUrl\n        .replace(/\\{\\{id_token\\}\\}/, id_token)\n        .replace(/\\{\\{client_id\\}\\}/, this.clientId);\n    } else {\n      let params = new HttpParams();\n\n      if (id_token) {\n        params = params.set('id_token_hint', id_token);\n      }\n\n      const postLogoutUrl = this.postLogoutRedirectUri || this.redirectUri;\n      if (postLogoutUrl) {\n        params = params.set('post_logout_redirect_uri', postLogoutUrl);\n\n        if (state) {\n          params = params.set('state', state);\n        }\n      }\n\n      logoutUrl =\n        this.logoutUrl +\n        (this.logoutUrl.indexOf('?') > -1 ? '&' : '?') +\n        params.toString();\n    }\n    this.config.openUri(logoutUrl);\n  }\n\n  /**\n   * @ignore\n   */\n  public createAndSaveNonce(): Promise<string> {\n    const that = this;\n    return this.createNonce().then(function(nonce: any) {\n      // Use localStorage for nonce if possible\n      // localStorage is the only storage who survives a\n      // redirect in ALL browsers (also IE)\n      // Otherwiese we'd force teams who have to support\n      // IE into using localStorage for everything\n      if (\n        that.saveNoncesInLocalStorage &&\n        typeof window['localStorage'] !== 'undefined'\n      ) {\n        localStorage.setItem('nonce', nonce);\n      } else {\n        that._storage.setItem('nonce', nonce);\n      }\n      return nonce;\n    });\n  }\n\n  /**\n   * @ignore\n   */\n  public ngOnDestroy(): void {\n    this.clearAccessTokenTimer();\n    this.clearIdTokenTimer();\n\n    this.removeSilentRefreshEventListener();\n    const silentRefreshFrame = this.document.getElementById(\n      this.silentRefreshIFrameName\n    );\n    if (silentRefreshFrame) {\n      silentRefreshFrame.remove();\n    }\n\n    this.stopSessionCheckTimer();\n    this.removeSessionCheckEventListener();\n    const sessionCheckFrame = this.document.getElementById(\n      this.sessionCheckIFrameName\n    );\n    if (sessionCheckFrame) {\n      sessionCheckFrame.remove();\n    }\n  }\n\n  protected createNonce(): Promise<string> {\n    return new Promise(resolve => {\n      if (this.rngUrl) {\n        throw new Error(\n          'createNonce with rng-web-api has not been implemented so far'\n        );\n      }\n\n      /*\n       * This alphabet is from:\n       * https://tools.ietf.org/html/rfc7636#section-4.1\n       *\n       * [A-Z] / [a-z] / [0-9] / \"-\" / \".\" / \"_\" / \"~\"\n       */\n      const unreserved =\n        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\n      let size = 45;\n      let id = '';\n\n      const crypto =\n        typeof self === 'undefined' ? null : self.crypto || self['msCrypto'];\n      if (crypto) {\n        let bytes = new Uint8Array(size);\n        crypto.getRandomValues(bytes);\n\n        // Needed for IE\n        if (!bytes.map) {\n          (bytes as any).map = Array.prototype.map;\n        }\n\n        bytes = bytes.map(x => unreserved.charCodeAt(x % unreserved.length));\n        id = String.fromCharCode.apply(null, bytes);\n      } else {\n        while (0 < size--) {\n          id += unreserved[(Math.random() * unreserved.length) | 0];\n        }\n      }\n\n      resolve(base64UrlEncode(id));\n    });\n  }\n\n  protected async checkAtHash(params: ValidationParams): Promise<boolean> {\n    if (!this.tokenValidationHandler) {\n      this.logger.warn(\n        'No tokenValidationHandler configured. Cannot check at_hash.'\n      );\n      return true;\n    }\n    return this.tokenValidationHandler.validateAtHash(params);\n  }\n\n  protected checkSignature(params: ValidationParams): Promise<any> {\n    if (!this.tokenValidationHandler) {\n      this.logger.warn(\n        'No tokenValidationHandler configured. Cannot check signature.'\n      );\n      return Promise.resolve(null);\n    }\n    return this.tokenValidationHandler.validateSignature(params);\n  }\n\n  /**\n   * Start the implicit flow or the code flow,\n   * depending on your configuration.\n   */\n  public initLoginFlow(additionalState = '', params = {}): void {\n    if (this.responseType === 'code') {\n      return this.initCodeFlow(additionalState, params);\n    } else {\n      return this.initImplicitFlow(additionalState, params);\n    }\n  }\n\n  /**\n   * Starts the authorization code flow and redirects to user to\n   * the auth servers login url.\n   */\n  public initCodeFlow(additionalState = '', params = {}): void {\n    if (this.loginUrl !== '') {\n      this.initCodeFlowInternal(additionalState, params);\n    } else {\n      this.events\n        .pipe(filter(e => e.type === 'discovery_document_loaded'))\n        .subscribe(_ => this.initCodeFlowInternal(additionalState, params));\n    }\n  }\n\n  private initCodeFlowInternal(additionalState = '', params = {}): void {\n    if (!this.validateUrlForHttps(this.loginUrl)) {\n      throw new Error(\n        \"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\"\n      );\n    }\n\n    this.createLoginUrl(additionalState, '', null, false, params)\n      .then(this.config.openUri)\n      .catch(error => {\n        console.error('Error in initAuthorizationCodeFlow');\n        console.error(error);\n      });\n  }\n\n  protected async createChallangeVerifierPairForPKCE(): Promise<\n    [string, string]\n  > {\n    if (!this.crypto) {\n      throw new Error(\n        'PKCE support for code flow needs a CryptoHander. Did you import the OAuthModule using forRoot() ?'\n      );\n    }\n\n    const verifier = await this.createNonce();\n    const challengeRaw = await this.crypto.calcHash(verifier, 'sha-256');\n    const challenge = base64UrlEncode(challengeRaw);\n\n    return [challenge, verifier];\n  }\n\n  private extractRecognizedCustomParameters(\n    tokenResponse: TokenResponse\n  ): Map<string, string> {\n    let foundParameters: Map<string, string> = new Map<string, string>();\n    if (!this.config.customTokenParameters) {\n      return foundParameters;\n    }\n    this.config.customTokenParameters.forEach((recognizedParameter: string) => {\n      if (tokenResponse[recognizedParameter]) {\n        foundParameters.set(\n          recognizedParameter,\n          JSON.stringify(tokenResponse[recognizedParameter])\n        );\n      }\n    });\n    return foundParameters;\n  }\n}\n","export abstract class OAuthModuleConfig {\n  resourceServer: OAuthResourceServerConfig;\n}\n\nexport abstract class OAuthResourceServerConfig {\n  /**\n   * Urls for which calls should be intercepted.\n   * If there is an ResourceServerErrorHandler registered, it is used for them.\n   * If sendAccessToken is set to true, the access_token is send to them too.\n   */\n  allowedUrls?: Array<string>;\n  sendAccessToken: boolean;\n  customUrlValidation?: (url: string) => boolean;\n}\n","import { HttpResponse } from '@angular/common/http';\nimport { Observable, throwError } from 'rxjs';\n\nexport abstract class OAuthResourceServerErrorHandler {\n  abstract handleError(err: HttpResponse<any>): Observable<any>;\n}\n\nexport class OAuthNoopResourceServerErrorHandler\n  implements OAuthResourceServerErrorHandler {\n  handleError(err: HttpResponse<any>): Observable<any> {\n    return throwError(err);\n  }\n}\n","import { Injectable, Optional } from '@angular/core';\n\nimport {\n  HttpEvent,\n  HttpHandler,\n  HttpInterceptor,\n  HttpRequest\n} from '@angular/common/http';\nimport { Observable, of, merge } from 'rxjs';\nimport {\n  catchError,\n  filter,\n  map,\n  take,\n  mergeMap,\n  timeout\n} from 'rxjs/operators';\nimport { OAuthResourceServerErrorHandler } from './resource-server-error-handler';\nimport { OAuthModuleConfig } from '../oauth-module.config';\nimport { OAuthStorage } from '../types';\nimport { OAuthService } from '../oauth-service';\n\n@Injectable()\nexport class DefaultOAuthInterceptor implements HttpInterceptor {\n  constructor(\n    private authStorage: OAuthStorage,\n    private oAuthService: OAuthService,\n    private errorHandler: OAuthResourceServerErrorHandler,\n    @Optional() private moduleConfig: OAuthModuleConfig\n  ) {}\n\n  private checkUrl(url: string): boolean {\n    if (this.moduleConfig.resourceServer.customUrlValidation) {\n      return this.moduleConfig.resourceServer.customUrlValidation(url);\n    }\n\n    if (this.moduleConfig.resourceServer.allowedUrls) {\n      return !!this.moduleConfig.resourceServer.allowedUrls.find(u =>\n        url.startsWith(u)\n      );\n    }\n\n    return true;\n  }\n\n  public intercept(\n    req: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    const url = req.url.toLowerCase();\n\n    if (\n      !this.moduleConfig ||\n      !this.moduleConfig.resourceServer ||\n      !this.checkUrl(url)\n    ) {\n      return next.handle(req);\n    }\n\n    const sendAccessToken = this.moduleConfig.resourceServer.sendAccessToken;\n\n    if (!sendAccessToken) {\n      return next\n        .handle(req)\n        .pipe(catchError(err => this.errorHandler.handleError(err)));\n    }\n\n    return merge(\n      of(this.oAuthService.getAccessToken()).pipe(\n        filter(token => (token ? true : false))\n      ),\n      this.oAuthService.events.pipe(\n        filter(e => e.type === 'token_received'),\n        timeout(this.oAuthService.waitForTokenInMsec || 0),\n        catchError(_ => of(null)), // timeout is not an error\n        map(_ => this.oAuthService.getAccessToken())\n      )\n    ).pipe(\n      take(1),\n      mergeMap(token => {\n        if (token) {\n          const header = 'Bearer ' + token;\n          const headers = req.headers.set('Authorization', header);\n          req = req.clone({ headers });\n        }\n\n        return next\n          .handle(req)\n          .pipe(catchError(err => this.errorHandler.handleError(err)));\n      })\n    );\n  }\n}\n","import { ValidationHandler, ValidationParams } from './validation-handler';\n\n/**\n * A validation handler that isn't validating nothing.\n * Can be used to skip validation (at your own risk).\n */\nexport class NullValidationHandler implements ValidationHandler {\n  validateSignature(validationParams: ValidationParams): Promise<any> {\n    return Promise.resolve(null);\n  }\n  validateAtHash(validationParams: ValidationParams): Promise<boolean> {\n    return Promise.resolve(true);\n  }\n}\n","import { MemoryStorage } from './types';\n\nexport function createDefaultLogger() {\n  return console;\n}\n\nexport function createDefaultStorage() {\n  return typeof sessionStorage !== 'undefined'\n    ? sessionStorage\n    : new MemoryStorage();\n}\n","import { OAuthStorage, OAuthLogger } from './types';\nimport { NgModule, ModuleWithProviders } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\n\nimport { OAuthService } from './oauth-service';\nimport { UrlHelperService } from './url-helper.service';\n\nimport { OAuthModuleConfig } from './oauth-module.config';\nimport {\n  OAuthResourceServerErrorHandler,\n  OAuthNoopResourceServerErrorHandler\n} from './interceptors/resource-server-error-handler';\nimport { DefaultOAuthInterceptor } from './interceptors/default-oauth.interceptor';\nimport { ValidationHandler } from './token-validation/validation-handler';\nimport { NullValidationHandler } from './token-validation/null-validation-handler';\nimport { createDefaultLogger, createDefaultStorage } from './factories';\nimport {\n  HashHandler,\n  DefaultHashHandler\n} from './token-validation/hash-handler';\n\n@NgModule({\n  imports: [CommonModule],\n  declarations: [],\n  exports: []\n})\nexport class OAuthModule {\n  static forRoot(\n    config: OAuthModuleConfig = null,\n    validationHandlerClass = NullValidationHandler\n  ): ModuleWithProviders<OAuthModule> {\n    return {\n      ngModule: OAuthModule,\n      providers: [\n        OAuthService,\n        UrlHelperService,\n        { provide: OAuthLogger, useFactory: createDefaultLogger },\n        { provide: OAuthStorage, useFactory: createDefaultStorage },\n        { provide: ValidationHandler, useClass: validationHandlerClass },\n        { provide: HashHandler, useClass: DefaultHashHandler },\n        {\n          provide: OAuthResourceServerErrorHandler,\n          useClass: OAuthNoopResourceServerErrorHandler\n        },\n        { provide: OAuthModuleConfig, useValue: config },\n        {\n          provide: HTTP_INTERCEPTORS,\n          useClass: DefaultOAuthInterceptor,\n          multi: true\n        }\n      ]\n    };\n  }\n}\n","import { NullValidationHandler } from './null-validation-handler';\n\nconst err = `PLEASE READ THIS CAREFULLY:\n\nBeginning with angular-oauth2-oidc version 9, the JwksValidationHandler\nhas been moved to an library of its own. If you need it for implementing\nOAuth2/OIDC **implicit flow**, please install it using npm:\n\n  npm i angular-oauth2-oidc-jwks --save\n\nAfter that, you can import it into your application:\n\n  import { JwksValidationHandler } from 'angular-oauth2-oidc-jwks';\n\nPlease note, that this dependency is not needed for the **code flow**,\nwhich is nowadays the **recommented** one for single page applications.\nThis also results in smaller bundle sizes.\n`;\n\n/**\n * This is just a dummy of the JwksValidationHandler\n * telling the users that the real one has been moved\n * to an library of its own, namely angular-oauth2-oidc-utils\n */\nexport class JwksValidationHandler extends NullValidationHandler {\n  constructor() {\n    super();\n    console.error(err);\n  }\n}\n","import { InjectionToken } from '@angular/core';\nimport { AuthConfig } from './auth.config';\n\nexport const AUTH_CONFIG = new InjectionToken<AuthConfig>('AUTH_CONFIG');\n"]}